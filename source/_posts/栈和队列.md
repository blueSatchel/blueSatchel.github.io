---
title: 栈和队列
date: 2024-09-28 20:51:00
tags: 
      - c++
      - 算法
categories: leetcode
---

# 栈和队列

#### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

本题是一道模板题,创建两个栈in和out只需注意以下两点

1. 入元素入到in栈,出元素从out栈出
2. in栈往out栈倒元素需要一次性倒完,out栈只有为空的时候才能进元素

```cpp
class MyQueue {
public:
    stack<int> in;
    stack<int> out;
    MyQueue() {}

    void push(int x) { in.push(x); }

    int pop() {
        if (!out.empty()) {
            int a = out.top();
            out.pop();
            return a;
        } else {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
            int a = out.top();
            out.pop();
            return a;
        }
    }

    int peek() {
        if (!out.empty()) {
            int a = out.top();

            return a;
        } else {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
            int a = out.top();

            return a;
        }
    }

    bool empty() {
        if (in.empty() && out.empty()) {
            return true;
        } else {
            return false;
        }
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



#### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

用一个元素实现队列,元素正常入队,但是当出元素的时候需要把前n-1个元素出队再重新入队之后,再把第一个元素出队

```cpp
class MyStack {
public:
queue<int> q;
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);

    }
    
    int pop() {
        int move=q.size()-1;
        int temp=0;
        while(move--){
            temp=q.front();
            q.pop();
            q.push(temp);
        }
        temp=q.front();
        q.pop();
        return temp;

    }
    
    int top() {
        return q.back();//stl库里面的queue队尾元素是back
    }
    
    bool empty() {
        return q.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```



#### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

思路：遇到左括号就入栈，遇到右括号检查栈顶是不是对应的左括号（若栈为空说明右括号多了，也不合法），是则把左括号出栈，不是则说明不匹配，直接return false

最后遍历完字符串栈应该为空，若栈中还有剩余元素，则说明左括号多了

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;

        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
                st.push(s[i]);
            } else {
                //处理栈空但是来了右括号的情况
                if(s[i] == ')' || s[i] == ']' || s[i] == '}'){
                    if(st.empty()){
                        return false;
                    }
                }
                if (!st.empty() && s[i] == ')') {
                    if (st.top() == '(') {
                        st.pop();
                    } else {
                        //已经失配了,提前结束
                        return false;
                    }
                }
                if (!st.empty() && s[i] == ']') {
                    if (st.top() == '[') {
                        st.pop();
                    }
                    else {
                        return false;
                    }
                }
                if (!st.empty() && s[i] == '}') {
                    if (st.top() == '{') {
                        st.pop();
                    }
                    else {
                        return false;
                    }
                }
            }
        }
        if (!st.empty()) {
            return false;
        }
        return true;
    }
};
```



#### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

栈为空或者栈顶元素不等于当前元素则入栈当前元素，如果发现栈顶元素和当前遍历到的元素相同，则把栈顶元素出栈后继续循环，最后逐个出栈并且reverse即可

```cpp
string removeDuplicates(string s) {
        stack<char> st;
        for (int i = 0; i < s.length(); i++) {
            if (st.empty() || st.top() != s[i]) {
                st.push(s[i]);
            } else if (st.top() == s[i]) {
                st.pop();
            }
        }
        string res;
        while (!st.empty()) {
            res += st.top();
            st.pop();
        }
        reverse(res.begin(), res.end());
        return res;
    }
```



#### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

后缀表达式求值，遇到数字入栈，遇到操作符则弹出两个操作数计算完后再入栈

注意：先弹出的是右操作数，后弹出的是左操作数

```cpp
int evalRPN(vector<string>& tokens) {
        stack<int> nums;
        for (int i = 0; i < tokens.size(); i++) {
            // 遍历到操作符
            if (tokens[i] == "+") {
                int b = nums.top();
                nums.pop();
                int a = nums.top();
                nums.pop();
                nums.push(a + b);

            } else if (tokens[i] == "-") {
                int b = nums.top();
                nums.pop();
                int a = nums.top();
                nums.pop();
                nums.push(a - b);

            } else if (tokens[i] == "*") {
                int b = nums.top();
                nums.pop();
                int a = nums.top();
                nums.pop();
                nums.push(a * b);

            } else if (tokens[i] == "/") {
                int b = nums.top();
                nums.pop();
                int a = nums.top();
                nums.pop();
                nums.push(a / b);
            } else {
                // 是数字
                nums.push(stoi(tokens[i]));
            }
        }
        return nums.top();
    }
```

