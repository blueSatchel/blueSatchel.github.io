---
title: 查找
date: 2021-12-30 16:25:42
tags:
categories:
 
typora-root-url: ..
---

#### ASL总结:

无序表查找ASL:顺序查找ASL=(n+1)/2

有序表折半查找ASL=log<sub>2</sub>(n+1)-1

散列表上

- 完全无冲突,ASL=1
- 有冲突具体计算

ASL取决于

1. 散列函数
2. 处理冲突的方法
3. 散列表的装填因子α

α=表中填入的记录数/哈希表的长度

α越大,表中记录数越多,说明表装得约满,发生冲突的可能性就越大,查找时比较次数就越多

<!--more-->

##### 查找定义:

根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素或记录

##### 关键字

用来标识一个数据元素(或记录)的某个数据项的值

主关键字: 可唯一的标识一个记录的关键字

次关键字: 用以识别若干记录的关键字

静态查找表:仅作"查询"操作的查找表

动态查找表:作"插入"和"删除"操作的查找表

##### 如何评价查找算法

关键字的平均比较次数,也称**平均查找长度ASL**

<img src="../images/%E6%9F%A5%E6%89%BE/image-20211230163613538.png" alt="image-20211230163613538" style="zoom:67%;" />

### 顺序查找

优点:算法简单,逻辑次序无要求,且不同存储结构均适用

缺点:ASL太大,**ASL=(n+1)/2**

时间复杂度O(n)

##### 应用范围

顺序表或线性链表表示的静态查找表

表内元素之间无序

##### 设置哨兵的顺序查找

当数据元素特别大的时候，每次循环少进行一次越界判断，这样会节省几乎一般的时间。

##### 记录的查找概率不相等时如何提高查找效率

按照查找概率高低存储

##### 记录的查找概率无法测定时如何提高查找效率

按查找概率动态调整记录顺序

1)在每个记录中设一个访问频度域

2)始终保持记录按非递增有序的次序排列

3)每次查找后均将刚查到的记录直接移至表头

### 折半查找

特点:每次将待查记录所在区间缩小一半

**ASL=log<sub>2</sub>(n+1)-1**

缺点:只适合有序表且仅限于顺序存储结构

时间复杂度O(log<sub>2</sub>(n))

mid=(low+high)/2

key<mid则:high=mid-1

key>mid则:low=mid+1

key=mid,找到

high<low,结束,未找到

判定树,按照查找次数和层数对应建树

比较次数<=树的深度

满二叉树深度D=log<sub>2</sub>(n)+1

![image-20211230172538718](/images/%E6%9F%A5%E6%89%BE/image-20211230172538718.png)

### 分块查找

优点:插入和删除比较容易,无需进行大量移动

缺点:要增加一个索引表的存储空间并对厨师索引表进行排序运算

适用情况:如果线性表既要快速查找又经常动态变化,则可采用分块查找

步骤:

1.将表分成几块,表或者有序,或者分块有序(第二块中所有元素值比第一块大)

2.建立索引表





#### 二叉排序树

又称为二叉搜索树,二叉查找树

二叉排序树或是空树,或是满足如下性质的二叉树:

- 若其左子树非空,则左子树上所有结点的值均小于根节点的值
- 若其右子树为空,则右子树上所有结点的值均大于等于根节点的值
- 其左右子树本身又各是一棵二叉排序树

```c++
BStree SearchBST(BSTree T,KeyType key){
    if((!T)||key==T->data.key) return T;
    else if(key<T->data.key)
        return SearchBST(T->lchild,key);
    else return SearchBST(T->rchild,key);
}
```

ASL

二叉排序树每层各个结点的比较次数等于该层高度

含有n个结点的二叉排序树的平均查找长度和树的形态有关

**最好情况**,形态比较均衡,ASL=log2(n+1)-1;

O(log<sub>2</sub>(n))



**最坏情况**:,单支树,退化成顺序查找

ASL=(n+1)/2

O(n)

**不同插入次序的序列生成不同形态的二叉排序树**

二叉排序树---插入操作

根据大小选择左右子树,找到某个叶子结点的左子树或者右子树为空,则插入节点为该叶子结点的左孩子或者右孩子

二叉排序树---删除操作

- 被删除的节点是叶子结点,直接删除即可

- 被删除的节点只有左子树或者只有右子树,用其左子树或者右子树替换它即可
- 被删除的节点既有左子树,也有右子树

用它中序遍历序列的前驱来代替它,前驱是左子树中最大的结点

也可以用其后继替换之,后继是右子树中最小的结点



#### 平衡二叉树

平衡二叉树又称AVL树,一棵平衡二叉树或者是空树,或者是具有下列性质的二叉排序树:

- 左子树与右子树的高度之差的绝对值小于等于1
- 左子树和右子树也是平衡二叉排序树

平衡因子=结点左子树的高度-结点右子树的高度

**对于一棵有n个结点的AVL树,其高度保持在O(log2(n))数量级,ASL也保持在O(log2(n))量级**



失衡调整

- LL
- LR
- RL
- RR

调整原则:自己慢慢分析,没必要背口诀

- 降低高度
- 保持二叉排序树性质(一般都是选取中等大小的节点上升)
- 出现多个平衡因子绝对值相等的失衡节点,找最小的失衡子树进行调整
- 失去父节点的子节点尽量更换到跟自己差值比较小的父节点

根据所给序列建立平衡二叉树时,需要边插入边检查是否失衡,并进行调整



#### 散列表查找

优点:查找效率高

缺点:空间效率低

散列表基本思想:记录的存储位置与关键字之间存在对应关系

##### 冲突

不同关键字映射到同一个散列地址

##### 好的散列函数应满足

- 所选函数尽可能简单,以便提高转换速度
- 所选函数对关键码计算出的地址,应在整个地址区间中均匀分布,以减少空间浪费

##### 一些常见方法

​	1.直接定址法

hash(key)=a key+b

优点:以关键字的某个线性函数值为散列地址,不会产生冲突

缺点:浪费空间

​	2.除留余数法

hash(key)=key mod p

**选取p的技巧**

设表长为m,取p<=m且p为质数

### 常用解决冲突的方法

#### 开放地址法

基本思想:有冲突的时候就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将数据元素存入

例如:除留余数法 H<sub>i</sub>=(Hash(key)+d<sub>i</sub>)mod m,d<sub>i</sub>为增量序列

**常用方法**

α=表中填入的记录数/哈希表的长度

![image-20211231011652431](/images/%E6%9F%A5%E6%89%BE/image-20211231011652431.png)

##### 线性探测法

增量序列d<sub>i</sub>为线性序列

##### 二次探测法

增量序列d<sub>i</sub>为二次序列1²,(-1)², 2², (-2)²  ....  ,q² 二次序列

##### 伪随机探测法

增量序列d<sub>i</sub>为伪随机数

#### 再哈希法



#### 链地址法(拉链法)

**优点:**

1.非同义词不会冲突,无"聚集"现象

2.链表上节点空间动态申请,更适合于表长不确定的情况

基本思想:相同散列地址的记录链成一单链表

m个散列地址就设m个单链表,然后用一个数组将m个单链表的表头指针存储起来,形成一个动态的结构

#### 建立一个公共溢出区
