---
title: 并查集
date: 2024-10-09 10:42:17
tags:
---

# 并查集

##### 基础

对于并查集来说,最基本的三个操作就是

1. find()
2. isSameSet();
3. union

其中isSameSet和union都需要用到find(),主要优化的过程在find和union中

最基础的两个数组

1. father数组,记录每个元素指向的父亲,初始都指向自己
2. size数组,记录每个集合的元素个数,初始情况下都为1,也就是自己一个人是一个集合

##### 优化

**扁平化**

在find中需要进行扁平化的操作,也就是在向上查找的过程中,把路过的结点都直接挂到最上层的结点,减少高度

可以用两种方式

1. 采用递归的方式,到顶了递归返回顶的值,然后利用递归返回值修改经过的节点
2. 用一个path记录经过的结点,找到顶之后再逐个修改

**小挂大**

也就是在union的时候,保持小的集合挂到大的集合上面



### 题目

#### [并查集的实现](https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372)

这题时间要求有点高,只能用数组操作,不能用vector

![image-20241009123022121](https://blue-satchel.oss-cn-chengdu.aliyuncs.com/img/202410091230185.png)

```cpp
#include <iostream>
using namespace std;
#include <vector>
int find(int father[], int num) {
    //扁平化
    //这里可以递归调用
    //也可以用path记录再逐个修改father对应的值
    if (num != father[num]) {
        father[num] = find(father, father[num]);
    }
    return father[num];
}
bool isSameSet(int father[], int a, int b) {
    return find(father, a) == find(father, b);
}
void unionSet(int father[], int size[], int a, int b) {
    int fa = find(father, a);
    int fb = find(father, b);
    if (fa != fb) {
        if (size[fa] < size[fb]) {
            //小挂大
            father[fa] = fb;
            size[fb] += size[fa];
        } else {
            father[fb] = fa;
            size[fa] += size[fb];
        }
        father[fa] = father[fb];
    }
}
int main() {
    int n, m;
    cin >> n >> m;
    int father[1000003];
    int size[1000003] = {1};
    for (int i = 1; i <= n; i++) {
        father[i] = i;
    }
    int opt, b, c;
    while (m--) {
        cin >> opt;
        if (opt == 1) {
            cin >> b >> c;
            bool res = isSameSet(father, b, c);
            if (res) {
                cout << "Yes" << endl;
            } else {
                cout << "No" << endl;
            }
        } else if (opt == 2) {
            cin >> b >> c;
            unionSet(father, size, b, c);
        }

    }

}

```

