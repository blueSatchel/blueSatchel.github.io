<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":30,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="java多线程学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="java多线程学习记录">
<meta property="og:url" content="http://example.com/2022/08/04/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="blueSatchel&#39;s blog">
<meta property="og:description" content="java多线程学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220805135545694.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220805225223525.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812155935083.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812160208655.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812164219675.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812224758071.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812224743210.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220815175756390.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220816003428991.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220816140527344.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220817201024794.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220817201159396.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220818165125092.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220818221028397.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220818222217922.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220818224401783.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220819011214242.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220819221602805.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220820000504397.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821012121602.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821143804836.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821144443967.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821144933171.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821152550460.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821160517628.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822151634663.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822154013314.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822154050264.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822160953591.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822161546596.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822163534233.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822172950757.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822191225957.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822232958662.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220823000927977.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220823105618999.png">
<meta property="og:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220823123326082.png">
<meta property="article:published_time" content="2022-08-04T14:46:29.000Z">
<meta property="article:modified_time" content="2022-09-09T15:53:09.254Z">
<meta property="article:author" content="blueSatchel">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220805135545694.png">

<link rel="canonical" href="http://example.com/2022/08/04/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java多线程学习记录 | blueSatchel's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blueSatchel's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/04/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../images/avatar.PNG">
      <meta itemprop="name" content="blueSatchel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blueSatchel's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java多线程学习记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-04 22:46:29" itemprop="dateCreated datePublished" datetime="2022-08-04T22:46:29+08:00">2022-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-09 23:53:09" itemprop="dateModified" datetime="2022-09-09T23:53:09+08:00">2022-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/04/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/04/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">java多线程学习记录</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="多线程学习记录"><a href="#多线程学习记录" class="headerlink" title="多线程学习记录"></a>多线程学习记录</h1><h2 id="1-线程概述"><a href="#1-线程概述" class="headerlink" title="1.线程概述"></a>1.线程概述</h2><h3 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h3><h5 id="currentThread方法"><a href="#currentThread方法" class="headerlink" title="currentThread方法"></a>currentThread方法</h5><p>java中的任何一段代码都是执行在某个线程当中的,执行当前代码的线程就是 当前线程</p>
<p>同一段代码可能被不用的线程执行,因此当前线程是相对的,Thread.currentThread()方法的返回值是在代码实际运行时候的</p>
<p>大概来说就是调用某个方法的线程就是其currentThread()</p>
<h5 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a>isAlive()</h5><p>判断当前线程是否处于活动状态(线程已启动且尚未终止)</p>
<h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h5><p>让当前线程休眠指定的毫秒数</p>
<h5 id="getId"><a href="#getId" class="headerlink" title="getId()"></a>getId()</h5><p>返回线程的唯一编号</p>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h5><p>作用是放弃当前的cpu资源</p>
<h5 id="setPriority-num"><a href="#setPriority-num" class="headerlink" title="setPriority(num)"></a>setPriority(num)</h5><p>1&lt;=num&lt;=10</p>
<p>本质上是给线程调度器一个提示信息,以便于调度器决定先调度哪些线程,不能完全保证优先级高的先运行</p>
<h5 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h5><p>仅仅是跟线程打一个中断标志</p>
<h5 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon()"></a>setDaemon()</h5><p>java中的线程分为用户线程与守护线程</p>
<p>守护线程是为其他线程提供服务的线程,如GC就是一个典型的守护线程</p>
<p>守护线程不能单独运行,当JVM中没有其他用户线程,只有守护线程时,守护线程会自动销毁,jvm会退出</p>
<p><strong>启动</strong>之前就设置为守护线程</p>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>可以通过<code>getState()</code>方法来获取是Thread.State枚举类型定义的,有以下几种:</p>
<table>
<thead>
<tr>
<th>Thread.State的值</th>
<th>具体含义</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>创建了线程对象但还没有启动</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>它是一个复合状态,包含READY和RUNNING两个状态,READY表示可以被调度器调度从而使它处于RUNNING状态</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态,线程发起阻塞的I/O操作,或者申请由其他线程占用的独占资源,线程会转换为BLOCKED阻塞状态,处于阻塞状态的线程不会占用CPU资源,当阻塞I/O操作执行完,或者线程获得了由其申请的资源,线程就可以转换为RUNNABLE状态</td>
</tr>
<tr>
<td>WAITING</td>
<td>线程执行了Object.wait方法,或者Thread.join方法,执行Object.notify方法或者加入的线程执行完毕,就会转换为RUNNABLE状态</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>一般调用Thread.sleep或者Object.wait()方法进入,与WAITING有点像,但是这个状态如果超过指定的时间范围,就会自动转换为RUNNABLE</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>线程结束,处于终止状态</td>
</tr>
</tbody></table>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220805135545694.png" alt="image-20220805135545694"></p>
<h3 id="多线程存在的问题与风险"><a href="#多线程存在的问题与风险" class="headerlink" title="多线程存在的问题与风险"></a>多线程存在的问题与风险</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多线程共享数据时,如果没有采取正确的并发访问控制措施,就可能会产生数据一致性问题,如读脏数据(过期的数据),如丢失数据更新</p>
<h4 id="线程活性"><a href="#线程活性" class="headerlink" title="线程活性"></a>线程活性</h4><p>由于程序自身的缺陷或者由资源稀缺性导致线程一直处于非RUNNABLE状态,这就是线程活性问题,常见的活性故障有以下几种</p>
<h5 id="死锁-Deadlock"><a href="#死锁-Deadlock" class="headerlink" title="死锁(Deadlock)"></a>死锁(Deadlock)</h5><p>最简单的例子是：线程 A 占有一号锁，正在请求二号锁，且线程 B 占有二号锁，正在请求一号锁，A、B 线程互相等待对方释放锁，进入了无线等待的状态。</p>
<h5 id="锁死-Lockout"><a href="#锁死-Lockout" class="headerlink" title="锁死(Lockout)"></a>锁死(Lockout)</h5><p>等待线程由于唤醒其所需的条件永远无法成立，或者其他线程无法唤醒这个线程而一直处于非运行状态（线程并未终止）导致其任务 一直无法进展</p>
<p><strong>类似于睡美人故事中王子挂了</strong></p>
<h5 id="活锁-Livelock"><a href="#活锁-Livelock" class="headerlink" title="活锁(Livelock)"></a>活锁(Livelock)</h5><p>活锁是指正在执行的线程或进程没有发生阻塞，但由于某些条件没有满足，导致反复重试-失败-重试-失败的过程。与死锁最大的区别在于：活锁状态的线程或进程是一直处于运行状态的，在失败中不断重试，重试中不断失败，一直处于所谓的“活”态，不会停止。</p>
<h5 id="饥饿-starvation"><a href="#饥饿-starvation" class="headerlink" title="饥饿(starvation)"></a>饥饿(starvation)</h5><p>资源总是被别的线程抢走了</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>可能会由一个线程导致JVM意外终止,其他的线程也无法执行</p>
<h2 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2.线程安全问题"></a>2.线程安全问题</h2><p>线程安全主要表现为三个方面:原子性,可见性和有序性</p>
<h4 id="原子性-Atomic"><a href="#原子性-Atomic" class="headerlink" title="原子性(Atomic)"></a>原子性(Atomic)</h4><p>就是不可分割的意思,原子操作的不可分割有两层含义:</p>
<ul>
<li>访问(读,写)某个共享变量的操作从其他线程来看,这个操作要么已经执行完毕,要么尚未发生,其他线程看不到当前这个操作的中间结果</li>
<li>访问同一组共享变量的原子操作时不能够交叉的</li>
</ul>
<p>java有两种方式实现原子性:一种是使用锁,另一种是利用处理器的CAS指令</p>
<ul>
<li><p>锁具有排他性,保证共享变量在某一时刻只能被一个线程访问</p>
</li>
<li><p>CAS指令直接在硬件(处理器和内存)层次上实现,看做是硬件锁</p>
</li>
</ul>
<h4 id="可见性-visibility"><a href="#可见性-visibility" class="headerlink" title="可见性(visibility)"></a>可见性(visibility)</h4><p>在多线程环境中,一个线程对某个共享变量进行更新之后,后续其他的线程可能无法立即读取到这个更新的结果,这就是线程安全问题的另外一种形式</p>
<p>如果一个线程对共享变量更新后,后序访问该变量的其他线程可以读取到更新的结果,称这个线程对共享变量的更新对其他线程可见,否则称这个线程对共享变量的更新对其他线程不可见</p>
<h4 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性(Ordering)"></a>有序性(Ordering)</h4><p>有序性是指在什么情况下一个处理器上运行的一个线程所执行的,内存访问操作在另外一个处理器运行的其他线程看起来是乱序的</p>
<p>乱序是指内存访问操作的顺序看起来发生了变化</p>
<h5 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h5><p>在多核处理器的环境下,编写的顺序结构,这种操作执行的顺序可能是没有保障的:</p>
<p>编译器可能会改变两个操作的先后顺序</p>
<p>处理器也可能不会按照目标代码的顺序执行</p>
<p>这种一个处理器上执行的多个操作,在其他处理器看来它的顺序与目标代码指定的顺序可能不一样,这种现象称为重排序</p>
<p>重排序是对内存访问有序操作的一种优化,可以在不影响单线程顺序正确的情况下提升程序的性能,但是可能对多线程程序的正确性产生影响,即可能导致线程安全问题</p>
<h5 id="与内存操作顺序有关的几个概念"><a href="#与内存操作顺序有关的几个概念" class="headerlink" title="与内存操作顺序有关的几个概念"></a>与内存操作顺序有关的几个概念</h5><p>源代码顺序:源码中指定的内存访问顺序</p>
<p>程序顺序:处理器上运行的目标代码所指定的内存访问顺序</p>
<p>执行顺序:内存访问操作在处理器上的实际执行顺序</p>
<p>感知顺序:给定处理器所感知到的该处理器及其他处理器的内存访问操作的顺序</p>
<p>可以把重排序分为指令重排序与存储子系统重排序两种</p>
<ul>
<li>指令重排序</li>
</ul>
<p>在源码顺序与程序顺序不一致,或者程序顺序与执行顺序不一致的情况下,我们就说发生了指令重排序</p>
<p>指令重拍是一种动作,确实对指令的顺序做了调整,重排序的对象是指令</p>
<p>javac编译器一般不会执行指令重排序,而jit编译器可能执行指令重排序</p>
<p>处理器也可能执行指令重排序,使得执行顺序与程序顺序不一致</p>
<p>指令重排序不会对单线程程序的结果产生影响,可能导致多线程程序出现非预期的结果</p>
<ul>
<li>存储子系统重排序</li>
</ul>
<p>存储子系统是指写缓冲器与高速缓存</p>
<p>高速缓存是CPU中为了匹配与主内存处理速度不匹配而设计的一个高速缓存,写缓冲器用来提高写告诉缓存操作的效率</p>
<p>即使处理器严格按照程序顺序执行两个内存访问操作,在存储子系统的作用下,其他处理器对这两个操作的感知顺序也可能与程序顺序不一致,即这两个操作的顺序看起来像是发生了变化,这种现象称为存储子系统重排序</p>
<p>存储子系统重排序对象是内存操作的结果</p>
<p>内存重排序分类</p>
<p>从处理器角度来看,读内存就是从指定的RAM地址中加载数据到寄存器,称为Load操作;写内存就是把数据存储到指定的地址表示的RAM存储单元中,称为Store操作,内存重排序有以下四种可能</p>
<p>LoadLoad重排序,一个处理器先后执行两个读操作L1和L2,其他处理器对两个内存操作的感知顺序可能是L2,L1</p>
<p>StoreStore重排序,一个处理器先后执行两个读操作W1和W2,其他处理器对两个内存操作的感知顺序可能是W2,W1</p>
<p>同理还有两种</p>
<p>LoadStore和StoreLoad重排序</p>
<h5 id="貌似串行语义"><a href="#貌似串行语义" class="headerlink" title="貌似串行语义"></a>貌似串行语义</h5><p>JIT编译器,处理器,存储子系统是按照一定的规则对指令内存操作的结果进行重排序,给单线程程序造成一种假象—指令是按照源码的顺序执行的,这种假象称为貌似串行语义</p>
<p>并不能保证多线程环境下程序的正确性</p>
<p>为了保证貌似串行语义,有数据依赖关系的语句不会被重排序,只有不存在数据依赖关系的语句才会被重排序</p>
<p>存在控制依赖关系的语句允许重拍,一条语句(指令)的执行结果会决定另一条语句(指令)能否被执行,这两条语句(指令)存在控制依赖关系,如在if语句中允许重排,可能存在处理器先执行if代码块,再判断If条件是否成立</p>
<h5 id="保证内存访问的顺序性"><a href="#保证内存访问的顺序性" class="headerlink" title="保证内存访问的顺序性"></a>保证内存访问的顺序性</h5><p>可以使用volatile关键字,synchronized关键字实现有序性</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>1.每个线程都有独立的栈空间</p>
<p>2.每个线程都可以访问堆内存</p>
<p>3.计算机的cpu不直接从内存读取数据,读的是从主存映射到cache的数据</p>
<p>4.jvm中的共享的数据可能会被分配到Register寄存器中,每个cpu都有自己的register寄存器,一个cpu不能读取其他cpu寄存器中的内容,如果两个线程分别运行在不同的处理器上</p>
<p>5.即使jvm中的共享数据分配到主内存中,也不能保证数据的可见性,cpu不直接对主内存访问,而是通过cache高速缓存进行的,一个处理器上运行的线程对数据的更新可能只是更新到处理器的写缓冲器中,还没有到达cache缓存,更不用说主内存了,另外一个处理器不能读取到该处理器写缓冲器上的内容,会产生运行在另外一个处理器上的线程无法看到该处理器对共享数据的更新</p>
<p>6.一个处理器的cache不能直接读取另外一个处理器的cache,但是一个处理器可以通过缓存一致性协议(Cache Coherence Protocol)来读取其他处理器缓存中的数据,并将读取到的数据更新到该处理器的cache中,这个过程称为缓存同步,缓存同步使得一个处理器上运行的线程可以读取到另外一个处理器上运行的线程对共享数据的所做的更新,即保障了可见性</p>
<p><strong>为了保障可见性,必须使一个处理器对共享数据的更新最终被写入该处理器的cache中,这个过程称为冲刷处理器缓存</strong></p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220805225223525.png" alt="image-20220805225223525"></p>
<h2 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3.线程同步"></a>3.线程同步</h2><h3 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h3><p>将多个线程对共享数据的并发访问转换为串行访问,即一个共享数据一次只能被一个线程访问</p>
<p>锁可以理解为对共享数据进行保护的一个许可证,对于同一个许可证保护的共享数据来说,任何相乘想要访问这些共享数据必须先持有该许可证,一个线程只有在持有许可证的情况下才能对这些共享数据进行访问,并且一个许可证一次只能被衣蛾线程持有,许可证线程在结束对共享数据的访问后必须释放其持有的许可证</p>
<p>一个线程在访问共享数据前必须先获得锁,获得锁的线程称为锁的持有线程,一个锁一次只能被一个线程持有.锁的持有线程在获得锁之后和释放锁之前这段时间锁执行的代码称为临界区(Critical Section)</p>
<p>锁具有排他性,即一个锁一次只能被一个线程持有,这种锁称为排它锁或互斥锁</p>
<p>jvm把锁分为内部锁和显示锁两种,内部锁通过synchronized关键字实现;显示锁通过Lock接口的实现类来实现</p>
<p>锁能够保障有序性,写线程在临界区所执行的在读线程所执行的临界区看来像是完全按照源码顺序执行的</p>
<p>注意:</p>
<p>使用锁保障线程的安全性,必须满足以下条件:</p>
<p><strong>这些线程在访问共享数据时必须使用同一个锁</strong></p>
<p><strong>即使是读取共享数据的线程也需要使用同步锁</strong></p>
<p><strong>锁的获得隐含着刷新处理器缓存的动作,释放锁隐含着处理器缓存冲刷的动作</strong>(拿进来改完再扔回去)</p>
<ul>
<li><strong>冲刷处理器缓存</strong>:当一个处理器对共享变量进行更新后,必须让它的更新最终被写入到高速缓冲或者主内存中.</li>
<li><strong>刷新处理器缓存</strong>:当处理器操作一个共享变量的时候,其它处理器在此之前已经对这个共享变量进行了更新,那么必须要对高速缓存或者主内存进行缓存同步.</li>
</ul>
<h4 id="锁相关的概念"><a href="#锁相关的概念" class="headerlink" title="锁相关的概念"></a>锁相关的概念</h4><h5 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h5><p>描述这样一个问题:一个线程持有该锁的时候能再次申请该锁</p>
<p>如果一个线程持有一个锁的时候还能够继续成功申请该锁,称该锁是可重入的,否则就称该锁为不可重入的</p>
<h5 id="锁的争用与调度"><a href="#锁的争用与调度" class="headerlink" title="锁的争用与调度"></a>锁的争用与调度</h5><p>java平台中内部锁属于非公平锁,显示Lock锁既支持公平锁又支持非公平锁</p>
<h5 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h5><p>一个锁可以保护的共享数据的数量大小称为锁的粒度</p>
<p>锁保护共享数据量大,称该锁的粒度粗,否则就称该锁的粒度细</p>
<p>锁的粒度过粗会导致线程在申请锁时会进行不必要的等待,锁的粒度过细会增加锁调度的开销</p>
<h5 id="内部锁synchronized关键字"><a href="#内部锁synchronized关键字" class="headerlink" title="内部锁synchronized关键字"></a>内部锁synchronized关键字</h5><p>java中的每个对象都有一个与之关联的内部锁,这种锁也称为监视器,这种内部锁是一种排他锁,可以保障原子性,可见性与有序性</p>
<p>内部锁是通过synchronized关键字实现的,synchronized关键字可以修饰代码块,修饰方法</p>
<p>修饰代码块的语法:</p>
<p>synchronized(锁对象,一般用this){</p>
<p>同步代码块,可以在同步代码块中访问共享数据</p>
<p>}</p>
<p>synchronized修饰实例对象,默认<strong>this</strong>作为锁对象</p>
<p>synchronized修饰静态方法,默认<strong>运行时类</strong>作为锁对象</p>
<p><strong>同步方法锁的粒度粗,同步代码块锁的粒度细</strong></p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>不仅对修改数据的代码块进行同步,还要对读取数据的代码块进行同步</p>
<p>如果不这样操作,可能会出现脏读的问题</p>
<h4 id="线程出现异常"><a href="#线程出现异常" class="headerlink" title="线程出现异常"></a>线程出现异常</h4><p>线程出现异常会自动释放锁</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>如何避免死锁?</p>
<p>所有线程获得锁的顺序保持一致即可</p>
<h3 id="轻量级同步机制-volatile关键字"><a href="#轻量级同步机制-volatile关键字" class="headerlink" title="轻量级同步机制:volatile关键字"></a>轻量级同步机制:volatile关键字</h3><p>volatile关键字可以强制线程从公共内存中读取变量的值,而不是从工作内存中读取</p>
<h5 id="volatile与synchronized关键字比较"><a href="#volatile与synchronized关键字比较" class="headerlink" title="volatile与synchronized关键字比较"></a>volatile与synchronized关键字比较</h5><p>1.volatile关键字是线程同步的轻量级实现,所以volatile性能肯定比synchronized要好,volatile只能修饰变量,而synchronized可以修饰方法,代码块,随着jdk新版本的发布,synchronized的执行效率也就较大的提升,在开发中使用synchronized的比率还是很大的</p>
<p>2.多线程访问volatile变量不会发生阻塞,而synchronized可能会阻塞</p>
<p>3.volatile能保证数据的可见性,但是不能保证原子性,而synchronized既可以保证原子性,也可以保证可见性</p>
<p>4.关键字volatile解决的是变量在多个线程之间的可见性,  synchronized解决的是多个线程之间访问公共资源的同步性</p>
<h5 id="volatile不能保证原子性的例子"><a href="#volatile不能保证原子性的例子" class="headerlink" title="volatile不能保证原子性的例子"></a>volatile不能保证原子性的例子</h5><p>是直接公共内存拿过来的,说不定其他线程对其的操作还未结束,拿到的是中间值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;num===&quot;</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812155935083.png" alt="image-20220812155935083" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///改为synchronized即可保证原子性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;num===&quot;</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812160208655.png" alt="image-20220812160208655" style="zoom:67%;" />

<h3 id="CAS-Compare-And-Swap-原理"><a href="#CAS-Compare-And-Swap-原理" class="headerlink" title="CAS(Compare And Swap)原理"></a>CAS(Compare And Swap)原理</h3><p>是由硬件实现的</p>
<p>CAS可以将read-modify-write这类的操作转换为原子操作</p>
<p>i++自增包括三个子操作</p>
<ul>
<li>从主内存读取i变量值</li>
<li>对i的值加1</li>
<li>再把加1后的值保存到主内存</li>
</ul>
<p>CAS原理:在把数据更新到主内存时,再次读取主内存变量的值,如果现在变量的值与期望的值(操作起始时读取的值)一样就更新</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812164219675.png" alt="image-20220812164219675"></p>
<p>使用代码模拟CAS算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">casTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CASCounter casCounter=<span class="keyword">new</span> CASCounter();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; System.out.println(casCounter.incrementAndGet())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CASCounter</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个Compare and swap方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> expectedValue,<span class="keyword">long</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(value==expectedValue)&#123;</span><br><span class="line">                value=newValue;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> oldValue;</span><br><span class="line">        <span class="keyword">long</span> newValue;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            oldValue=value;</span><br><span class="line">            newValue=oldValue+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cas() return false之后撤销本次递增,再增加一次</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (!cas(oldValue,newValue));</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS实现原子操作背后有一个假设:共享变量的当前值与当前线程提供的期望值相同,就认为这个变量没有被其他线程修改过</p>
<p>实际上这种假设不一定总是成立,如有共享变量count=0</p>
<p>A线程将count修改为10,B线程将count修改为20,C线程将count值修改为0</p>
<p>当前线程看到count的值为0,<strong>不能简单的认为count的值没有被其他线程更新</strong></p>
<p>这就是CAS中的ABA问题,即共享变量经历了A-&gt;B-&gt;A,是否能够接受ABA问题跟实现的算法有关,如果想要规避ABA问题,可以为共享变量引入一个修订号(时间戳),每次修改共享变量时,相应的修订号发生变化AtmicStampedReference类就是基于这种思想产生的</p>
<h4 id="原子变量类概述"><a href="#原子变量类概述" class="headerlink" title="原子变量类概述"></a>原子变量类概述</h4><p>原子变量类基于CAS实现,其内部就是借助一个volatile变量</p>
<table>
<thead>
<tr>
<th>分组</th>
<th>原子变量类</th>
</tr>
</thead>
<tbody><tr>
<td>基础数据型</td>
<td>AtomicInteger,AtomicLong,AtomicBoolean</td>
</tr>
<tr>
<td>数组型</td>
<td>AtomicArray,AtomicLongArray,AtomicReferenceArray</td>
</tr>
<tr>
<td>字段更新器</td>
<td>AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicReferenceFieldUpdater</td>
</tr>
<tr>
<td>引用型</td>
<td>AtomicReference,AtomicStampedReference,AtomicMarkableReference</td>
</tr>
</tbody></table>
<h5 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h5><p>AtomicIntegerFieldUpdater可以对原子整数字段进行更新,要求:</p>
<p>1.字符必须使用volatile修饰,使线程之间可见</p>
<p>2.只能是实例变量,不能是静态变量,也不能使用final修饰</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> SubThread(user).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerFieldUpdater&lt;User&gt; updater=AtomicIntegerFieldUpdater.newUpdater(User.class,<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubThread</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user=user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(updater.getAndIncrement(user));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的几种也是这样的使用方式</p>
<h5 id="AtomicReference可能会出现CAS的ABA问题"><a href="#AtomicReference可能会出现CAS的ABA问题" class="headerlink" title="AtomicReference可能会出现CAS的ABA问题"></a>AtomicReference可能会出现CAS的ABA问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;String&gt; atomicReference=<span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                atomicReference.compareAndSet(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+atomicReference.get());</span><br><span class="line">                atomicReference.compareAndSet(<span class="string">&quot;def&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(atomicReference.compareAndSet(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(atomicReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812224758071.png" alt="image-20220812224758071"></p>
<h5 id="使用AtomicStampReference中的版本号来解决ABA问题"><a href="#使用AtomicStampReference中的版本号来解决ABA问题" class="headerlink" title="使用AtomicStampReference中的版本号来解决ABA问题"></a>使用AtomicStampReference中的版本号来解决ABA问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; stampedReference=<span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;abc&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                stampedReference.compareAndSet(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&quot;</span>+stampedReference.getReference());</span><br><span class="line">                stampedReference.compareAndSet(<span class="string">&quot;def&quot;</span>,<span class="string">&quot;abc&quot;</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> stamp=stampedReference.getStamp();</span><br><span class="line">                <span class="comment">//先获得了版本号,但是sleep期间上面的线程导致版本号+1了</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//此处版本号不一致,所以并没有做出修改</span></span><br><span class="line">                System.out.println(stampedReference.compareAndSet(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;hello&quot;</span>,stamp,stamp+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(stampedReference.getReference());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220812224743210.png" alt="image-20220812224743210"></p>
<h2 id="4-线程间的通信"><a href="#4-线程间的通信" class="headerlink" title="4.线程间的通信"></a>4.线程间的通信</h2><h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>在多线程编程中,可能线程A的条件没有满足只是暂时的,稍后其他的线程B可能会更新条件使得A线程的条件得到满足,可以将A线程暂停,直到它的条件得到满足后,再将A线程唤醒</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="Object-wait"><a href="#Object-wait" class="headerlink" title="Object#wait()"></a>Object#wait()</h5><p><code>Object#wait()</code>方法可以是执行当前代码的线程等待,暂停执行直到接到通知或被中断为止</p>
<p><strong>注意:</strong></p>
<ol>
<li><strong>wait()方法只能在同步代码块中由锁对象调用</strong></li>
<li><strong>调用wait()方法,当前线程会释放锁</strong></li>
</ol>
<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在调用wait()方法前获得对象的内部锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">        <span class="comment">//通过锁对象调用wait()方法暂停线程,会释放锁对象</span></span><br><span class="line">        锁对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程的条件满足了继续向下执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait(long)也可以提供一个毫秒让它到时间自动唤醒</p>
<h5 id="Object-notify"><a href="#Object-notify" class="headerlink" title="Object#notify()"></a>Object#notify()</h5><p>Object类的notify()可以唤醒线程,<strong>该方法也必须在同步代码块中由锁对象调用</strong>,没有使用锁对象调用wait()/notify()会抛出IllegalMonitorStateException异常,如果有多个等待的线程,notify()方法只能唤醒其中的一个,<strong>在同步代码块中调用nitify()方法后,并不会立即释放锁对象,需要等当前同步代码看执行完后才会释放锁对象,一般将notify方法放在同步代码块的最后</strong></p>
<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">//执行修改保护条件的代码</span></span><br><span class="line">    <span class="comment">//唤醒其他线程</span></span><br><span class="line">    锁对象.notify();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String lock=<span class="string">&quot;hello!!!&quot;</span>;<span class="comment">//定义一个String类作为锁对象</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1开始等待&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();<span class="comment">//线程等待,会释放锁对象,线程进入blocked阻塞状态</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1等待结束&quot;</span>+System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//notify方法也需要在同步代码块中由锁对象调用</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2开始唤醒&quot;</span>+System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">                    lock.notify();<span class="comment">//唤醒在lock锁对象上等待的某一个线程</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2唤醒结束&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220815175756390.png" alt="image-20220815175756390"></p>
<h5 id="notify不会立即释放锁对象"><a href="#notify不会立即释放锁对象" class="headerlink" title="notify不会立即释放锁对象"></a>notify不会立即释放锁对象</h5><p><strong>唤醒线程不会立即释放锁对象,需要等到当前同步代码块都执行完后才能释放锁对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(list.size()!=<span class="number">5</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1开始等待&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            list.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1被唤醒&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                        list.add(<span class="string">&quot;string&quot;</span>+i);</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2添加了第&quot;</span>+i+<span class="string">&quot;个数据&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(list.size()==<span class="number">5</span>)&#123;</span><br><span class="line">                            list.notify();</span><br><span class="line">                            System.out.println(<span class="string">&quot;线程2已结发起唤醒通知&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);<span class="comment">//保证线程1先执行</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220816003428991.png" alt="image-20220816003428991" style="zoom:80%;" />

<h5 id="interrupt-方法会中断wait"><a href="#interrupt-方法会中断wait" class="headerlink" title="interrupt()方法会中断wait()"></a>interrupt()方法会中断wait()</h5><p>当线程处于wait()等待状态时, 调佣线程对象的interrupt()方法会中断线程的等待状态,会产生Interrupted</p>
<p>中断线程会唤醒线程等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;等待开始&quot;</span>);</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;等待结束&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;wait被中断了&quot;</span>);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220816140527344.png" alt="image-20220816140527344"></p>
<h5 id="notify-与notifyAll"><a href="#notify-与notifyAll" class="headerlink" title="notify()与notifyAll()"></a>notify()与notifyAll()</h5><p>锁对象.notify()一次只能唤醒一个线程,如果有多个等待的线程,只能随机唤醒其中的某一个,想要唤醒所有等待的线程,需要调用锁对象.notifyAll()</p>
<h5 id="通知过早"><a href="#通知过早" class="headerlink" title="通知过早"></a>通知过早</h5><p>如果先开启通知线程,再开启等待线程,可能会出现t1线程等待没有收到通知的情况</p>
<p>比较好的解决办法就是设置一个isFirst的静态布尔变量,当线程是第一个开启的就等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread1&#123;</span><br><span class="line">    <span class="keyword">while</span>(isFirst)&#123;</span><br><span class="line">    	锁对象.lock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread2&#123;</span><br><span class="line">    锁对象.notify()</span><br><span class="line">    isFirst=<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="wait条件发生了变化"><a href="#wait条件发生了变化" class="headerlink" title="wait条件发生了变化"></a>wait条件发生了变化</h5><p>在使用wait/notify模式时,注意wait条件发生了变化,也可能会造成程序逻辑的混乱</p>
<p>先开启添加数据的线程,再开启一个取数据的线程,大多数情况下会正常取数据</p>
<p>先开启取数据的线程,再开启添加数据的线程,取数据的线程会先等待,等到添加数据之后nofity后再取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subtract</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            Object o = list.remove(<span class="number">0</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;从集合中取了&quot;</span>+o+<span class="string">&quot;,,,剩余数量为&quot;</span>+list.size());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line"></span><br><span class="line">            list.add(<span class="string">&quot;datum&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;添加了一条数据&quot;</span>);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SubtractThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            subtract();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SubtractThread subtractThread1=<span class="keyword">new</span> SubtractThread();</span><br><span class="line">        SubtractThread subtractThread2=<span class="keyword">new</span> SubtractThread();</span><br><span class="line">        subtractThread1.setName(<span class="string">&quot;subtractThread1&quot;</span>);</span><br><span class="line">        subtractThread2.setName(<span class="string">&quot;subtractThread2&quot;</span>);</span><br><span class="line">        AddThread addThread1=<span class="keyword">new</span> AddThread();</span><br><span class="line">        addThread1.setName(<span class="string">&quot;addThread1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启两个取数据的线程,再开启添加数据的线程</span></span><br><span class="line">        subtractThread1.start();</span><br><span class="line">        subtractThread2.start();</span><br><span class="line">        addThread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220817201024794.png" alt="image-20220817201024794" style="zoom: 80%;" />

<p>当等待的线程被唤醒后,需要再判断一次集合中是否有数据可取,即需要把subtract()方法中的if判断改为while,改完后上述代码执行结果发生如下转变</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220817201159396.png" alt="image-20220817201159396"></p>
<h4 id="生产者消费者设计模式"><a href="#生产者消费者设计模式" class="headerlink" title="生产者消费者设计模式"></a>生产者消费者设计模式</h4><p>有多个线程的时候为了防止取不到值的问题,把if改为while</p>
<p>ValueOP</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.producerTest;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueOP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//定义方法修改value的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//如果不是空串就等待</span></span><br><span class="line">            <span class="keyword">while</span> (!value.equalsIgnoreCase(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果value值是空串,就设置value字段的值</span></span><br><span class="line">            String value=System.currentTimeMillis()+<span class="string">&quot;--&quot;</span>+System.nanoTime();</span><br><span class="line">            System.out.println(<span class="string">&quot;set设置的值是:&quot;</span>+value);</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//是空串就等待</span></span><br><span class="line">            <span class="keyword">while</span> (value.equalsIgnoreCase(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是空串,读取字段值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;get的值是:&quot;</span>+value);</span><br><span class="line">            <span class="keyword">this</span>.value=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProducerThread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.producerTest;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ValueOP obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerThread</span><span class="params">(ValueOP obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            obj.setValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConsumerThread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.producerTest;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ValueOP obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(ValueOP obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            obj.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ValueOP valueOP=<span class="keyword">new</span> ValueOP();</span><br><span class="line">        ProducerThread p1=<span class="keyword">new</span> ProducerThread(valueOP);</span><br><span class="line">        ProducerThread p2=<span class="keyword">new</span> ProducerThread(valueOP);</span><br><span class="line">        ProducerThread p3=<span class="keyword">new</span> ProducerThread(valueOP);</span><br><span class="line">        ConsumerThread c1=<span class="keyword">new</span> ConsumerThread(valueOP);</span><br><span class="line">        ConsumerThread c2=<span class="keyword">new</span> ConsumerThread(valueOP);</span><br><span class="line">        ConsumerThread c3=<span class="keyword">new</span> ConsumerThread(valueOP);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        p3.start();</span><br><span class="line">        c3.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220818165125092.png" alt="image-20220818165125092"></p>
<p>但是上述代码可能会出现线程假死的状态,所有线程一直处于等待状态</p>
<p>大概原因是锁对象.notify()是随机唤醒一个线程,有很大可能不是按照预期的,消费结束就去唤醒生产者线程</p>
<p>所以需要将上述ValueOP类代码中的notify()改为notifyAll()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueOP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//定义方法修改value的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//如果不是空串就等待</span></span><br><span class="line">            <span class="keyword">while</span> (!value.equalsIgnoreCase(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果value值是空串,就设置value字段的值</span></span><br><span class="line">            String value=System.currentTimeMillis()+<span class="string">&quot;--&quot;</span>+System.nanoTime();</span><br><span class="line">            System.out.println(<span class="string">&quot;set设置的值是:&quot;</span>+value);</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//是空串就等待</span></span><br><span class="line">            <span class="keyword">while</span> (value.equalsIgnoreCase(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是空串,读取字段值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;get的值是:&quot;</span>+value);</span><br><span class="line">            <span class="keyword">this</span>.value=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h5><p>相比上面的操作方式,还可以通过模拟栈的方式,来安排消费者和生产者</p>
<p>MyStack.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类模拟栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List list= <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当栈已满,就等待\</span></span><br><span class="line">        <span class="keyword">while</span> (list.size()&gt;=MAX)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String data=<span class="string">&quot;data---&quot;</span>+Math.random();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;添加了数据&quot;</span>+data);</span><br><span class="line">        list.add(data);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (list.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;出栈数据:  &quot;</span>+list.remove(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过管道实现线程间的通信"><a href="#通过管道实现线程间的通信" class="headerlink" title="通过管道实现线程间的通信"></a>通过管道实现线程间的通信</h4><p>通过管道在两个线程之间传输字节流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PipedInputStream inputStream=<span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        PipedOutputStream outputStream=<span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        <span class="comment">//在输入管道流与输出管道流之间建立连接</span></span><br><span class="line">        inputStream.connect(outputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新线程向管道流中写入数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                writeData(outputStream);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                readData(inputStream);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">(PipedOutputStream out)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                    String data=<span class="string">&quot;&quot;</span>+i;</span><br><span class="line">                    out.write(data.getBytes());<span class="comment">//把字节数组写入到输出管道流中</span></span><br><span class="line">                &#125;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(PipedInputStream in)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//从管道输入字节流中读取字节保存到字节数组中</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len=in.read(bytes);</span><br><span class="line">            <span class="keyword">while</span> (len!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//把bytes数组中从0开始读到的len个字节转换为字符串打印</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">                len=in.read(bytes);<span class="comment">//继续向下读</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>除了控制资源的访问外,还可以通过增加资源来保证线程安全.</p>
<p>ThradLocal主要解决为每个线程绑定自己的值</p>
<p>给每一个线程都给一个<code>SimpleDateFormat</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">//定义Runnable接口实现类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String text=<span class="string">&quot;2099年11月23日 08:39:&quot;</span>+i%<span class="number">60</span>;</span><br><span class="line">                <span class="comment">//设定threadLocal中的对象</span></span><br><span class="line">                <span class="keyword">if</span>(threadLocal.get()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    threadLocal.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                Date date=threadLocal.get().parse(text);</span><br><span class="line">                System.out.println(i+<span class="string">&quot;--&quot;</span>+date);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ParseDate(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过重写<code>ThreadLocal#initialValue()</code>方法来设置初始值,这样get()得到的就不是null了</p>
<h2 id="5-Lock显示锁"><a href="#5-Lock显示锁" class="headerlink" title="5.Lock显示锁"></a>5.Lock显示锁</h2><p>在JDK5中新增了LOCK锁接口,有ReentrantLock实现类,ReentranLock锁称为可重入锁,它的功能比synchronized多</p>
<h4 id="锁的可重入性"><a href="#锁的可重入性" class="headerlink" title="锁的可重入性"></a>锁的可重入性</h4><p>锁的可重入是指,当一个线程获得一个对象锁后,再次请求该对象锁时是可以获得该对象的锁的</p>
<p>一个简单的例子</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220818221028397.png" alt="image-20220818221028397"></p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="ReentrantLock的基本使用"><a href="#ReentrantLock的基本使用" class="headerlink" title="ReentrantLock的基本使用"></a>ReentrantLock的基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义显示锁</span></span><br><span class="line">    <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();<span class="comment">//获得锁</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---method 1---&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---method 1---&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();<span class="comment">//获得锁</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---method 2---&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---method 2---&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r1=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                sm1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable r2=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                sm2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220818222217922.png" alt="image-20220818222217922" style="zoom:67%;" />

<p>只要锁对象是同一个,就可以实现同步</p>
<h5 id="ReentrantLock的可重入性"><a href="#ReentrantLock的可重入性" class="headerlink" title="ReentrantLock的可重入性"></a>ReentrantLock的可重入性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">      <span class="comment">//这里定义为static的Lock对象的原因就是为了保证每个实例对象拿到的都是同一把锁</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               lock.lock();</span><br><span class="line">               num++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">               lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      SubThread t1=<span class="keyword">new</span> SubThread();</span><br><span class="line">      SubThread t2=<span class="keyword">new</span> SubThread();</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      <span class="comment">//使用join让main线程等待其执行</span></span><br><span class="line">      t1.join();</span><br><span class="line">      t2.join();</span><br><span class="line">      System.out.println(SubThread.num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220818224401783.png" alt="image-20220818224401783" style="zoom:67%;" />

<h5 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h5><p>lockInterruptibly()方法的作用:如果当前线程未被中断则获得锁,如果当前线程被中断则抛出异常</p>
<p><strong>lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</strong></p>
<p>==注意是:等待的那个线程B可以被中断，不是正在执行的A线程被中断==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();<span class="comment">//定义锁对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//lock.lock();//获得锁,即使调用了线程的interrupt()方法,该线程也没有真正的中断</span></span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--- begin lock&quot;</span>);</span><br><span class="line">                <span class="comment">//执行一段耗时的操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Integer.MAX_VALUE;i++)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--- end lock&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;*** 释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            Server s =<span class="keyword">new</span> Server();</span><br><span class="line">            Runnable r=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    s.serviceMethod();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread t1=<span class="keyword">new</span> Thread(r);</span><br><span class="line">            t1.start();</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            Thread t2=<span class="keyword">new</span> Thread(r);</span><br><span class="line">            t2.start();</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            t2.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220819011214242.png" alt="image-20220819011214242" style="zoom:67%;" />

<h5 id="lockInterruptibly-可以解决死锁问题"><a href="#lockInterruptibly-可以解决死锁问题" class="headerlink" title="lockInterruptibly()可以解决死锁问题"></a>lockInterruptibly()可以解决死锁问题</h5><p>对于synchronized内部锁来说,如果一个线程在等待锁,只有两个结果:要么该线程获得锁继续执行,要么就保持等待</p>
<p>==对于ReentrantedLock来说,可以在等待锁的过程中取消对锁的请求==</p>
<h5 id="trylock-方法"><a href="#trylock-方法" class="headerlink" title="trylock()方法"></a>trylock()方法</h5><h6 id="trylock-long-time-TimeUnit-unit"><a href="#trylock-long-time-TimeUnit-unit" class="headerlink" title="trylock(long time,TimeUnit unit)"></a>trylock(long time,TimeUnit unit)</h6><p>trylock(long time,TimeUnit unit)的作用在给定等待时长内锁没有被另外的线程持有,并且当前线程也没有被中断,则获得该锁,通过该方法可以实现锁对象的限时等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获得锁,执行耗时任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没有获得锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeLock timeLock=<span class="keyword">new</span> TimeLock();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(timeLock);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(timeLock);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220819221602805.png" alt="image-20220819221602805"></p>
<p>上述的执行结果中,Thread0先获得锁执行耗时4秒的任务,Thread1尝试获得锁,但是超过3秒之后Thread1就不在等待,直接放弃获得锁</p>
<h6 id="trylock"><a href="#trylock" class="headerlink" title="trylock()"></a>trylock()</h6><p>trylock()仅在调用时锁定未被其他线程持有的锁,如果调用方法时,锁对象被其他线程持有,则放弃</p>
<h6 id="trylock-可以避免死锁"><a href="#trylock-可以避免死锁" class="headerlink" title="trylock()可以避免死锁"></a>trylock()可以避免死锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lockNum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IntLock</span><span class="params">(<span class="keyword">int</span> lockNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lockNum = lockNum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lockNum % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁1,还想获得锁2&quot;</span>);</span><br><span class="line">                            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">                                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;同时获得锁1与锁2&quot;</span>);</span><br><span class="line">                                    <span class="keyword">return</span>;<span class="comment">//结束run方法</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) &#123;</span><br><span class="line">                                    lock2.unlock();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁2,还想获得锁1&quot;</span>);</span><br><span class="line">                            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">                                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;同时获得锁2与锁1&quot;</span>);</span><br><span class="line">                                    <span class="keyword">return</span>;<span class="comment">//结束run方法</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                                    lock1.unlock();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) &#123;</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntLock intLock1 = <span class="keyword">new</span> IntLock(<span class="number">11</span>);</span><br><span class="line">        IntLock intLock2 = <span class="keyword">new</span> IntLock(<span class="number">10</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(intLock1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(intLock2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//运行后,使用trylock()尝试获得锁,不会傻傻的等待,</span></span><br><span class="line">        <span class="comment">//通过循环不停的再次尝试,如果等待的时间足够长,线程总是或获得想要的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220820000504397.png" alt="image-20220820000504397"></p>
<p>实际上等了蛮长时间的,但是使用trylock()确实可以避免死锁</p>
<h5 id="newCondition-方法"><a href="#newCondition-方法" class="headerlink" title="newCondition()方法"></a>newCondition()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Condition condition=lock.newCondition();</span><br></pre></td></tr></table></figure>



<p>关键字synchronized与wait()/notify()这两个方法一起使用可以实现等待/通知模式,Lock锁的newCondition()方法返回Condition对象,Condition类也可以实现等待/通知模式</p>
<p>使用notify()通知时,JVM会随机唤醒某个等待的线程,使用Condition类可以进行选择性通知</p>
<p>await()会使当前线程等待,同时会释放锁,当其他线程调用signal()时,线程会重新获得锁并继续执行</p>
<p>signal()用于唤醒一个等待的线程</p>
<p>==不管是await()还是signal()都需要先持有锁==</p>
<p>注意:在调用Condition的await()/signal()方法前,也需要线程持有相关的Lock锁,调用await()后线程会释放这个锁,在singal()调用后会从当前Condition对象的等待队列中,唤醒一个线程,唤醒的线程会尝试获得锁,一旦获得锁成功就继续执行</p>
<h6 id="使用多个Condition对象实现通知部分线程"><a href="#使用多个Condition对象实现通知部分线程" class="headerlink" title="使用多个Condition对象实现通知部分线程"></a>使用多个Condition对象实现通知部分线程</h6><p>可以让多个condition对象管理多个等待</p>
<h6 id="使用Condition实现多线程交替打印"><a href="#使用Condition实现多线程交替打印" class="headerlink" title="使用Condition实现多线程交替打印"></a>使用Condition实现多线程交替打印</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> Condition condition=lock.newCondition();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">                flag=<span class="keyword">false</span>;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyService myService=<span class="keyword">new</span> MyService();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                        myService.printOne();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                        myService.printTwo();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>大多数情况下,锁的很强都是非公平的,如果线程1与线程2都在请求锁A,当锁A可用时,系统只是会从阻塞队列中随机的选择一个线程,不能保证其公平性</p>
<p>公平锁会按照时间先后顺序,保证先到先得,后到后得,公平锁的这一特点不会出现线程饥饿现象</p>
<p>synchronized是非公平锁,</p>
<p>ReentrantLock重入锁提供了一个构造方法:ReentrantLock(boolean fair),当在创建锁对象时实参传递true就可以把该锁设置为公平锁</p>
<p>如果是非公平锁,系统倾向于让一个线程再次获得已经持有的锁,这种分配策略是高效的,非公平的</p>
<p>如果是公平锁,多个线程不会发生同一个线程连续多次获得锁的可能,保证了公平性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.lock();</span><br><span class="line"></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获得了锁对象&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中个让线程获得锁对象的顺序一开始是什么样,之后就是不断的轮回</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821012121602.png" alt="image-20220821012121602"></p>
<blockquote>
<p>公平锁看起来很公平,但是要实现公平锁必须要求系统维护一个有序队列,公平锁的实现成本较高,性能也较低,因此默认情况下锁是非公平的,不是特别的需求,一般不适用公平锁</p>
</blockquote>
<h5 id="ReentrantLock几个常用的方法"><a href="#ReentrantLock几个常用的方法" class="headerlink" title="ReentrantLock几个常用的方法"></a>ReentrantLock几个常用的方法</h5><h6 id="int-getHoldCount"><a href="#int-getHoldCount" class="headerlink" title="int getHoldCount()"></a>int getHoldCount()</h6><p>方法可以返回当前线程调用lock方法的次数</p>
<h6 id="int-getQueueLength"><a href="#int-getQueueLength" class="headerlink" title="int getQueueLength()"></a>int getQueueLength()</h6><p>返回正等待获得锁的线程<strong>预估数</strong></p>
<h6 id="int-getWaitQueueLength-Condition-condition"><a href="#int-getWaitQueueLength-Condition-condition" class="headerlink" title="int getWaitQueueLength(Condition condition)"></a>int getWaitQueueLength(Condition condition)</h6><p>返回与Condition相关的等待的线程预估数</p>
<h6 id="hasQueuedThread-Thread-thread"><a href="#hasQueuedThread-Thread-thread" class="headerlink" title="hasQueuedThread(Thread thread)"></a>hasQueuedThread(Thread thread)</h6><p>查询参数执行的线程是否在等待获得锁</p>
<h6 id="hasQueuedThreads"><a href="#hasQueuedThreads" class="headerlink" title="hasQueuedThreads()"></a>hasQueuedThreads()</h6><p>查询是否还有线程在等待获得该锁</p>
<h6 id="boolean-hasWaiters-Condition-condition"><a href="#boolean-hasWaiters-Condition-condition" class="headerlink" title="boolean hasWaiters(Condition condition)"></a>boolean hasWaiters(Condition condition)</h6><p>查询是否有线程正在等待指定的condition条件</p>
<h6 id="boolean-isFair"><a href="#boolean-isFair" class="headerlink" title="boolean isFair()"></a>boolean isFair()</h6><p>判断是否为公平锁</p>
<h6 id="boolean-isHeldByCurrentThread"><a href="#boolean-isHeldByCurrentThread" class="headerlink" title="boolean isHeldByCurrentThread()"></a>boolean isHeldByCurrentThread()</h6><p>判断当前线程是否持有该锁</p>
<h6 id="boolean-islocked"><a href="#boolean-islocked" class="headerlink" title="boolean islocked()"></a>boolean islocked()</h6><p>查询当前锁是否被线程持有,释放了锁对象后返回false</p>
<h4 id="ReentrantReadWriteLock读写锁"><a href="#ReentrantReadWriteLock读写锁" class="headerlink" title="ReentrantReadWriteLock读写锁"></a>ReentrantReadWriteLock读写锁</h4><p>synchronized内部锁与ReentrantLock锁都是独占锁(排它锁),同一时间只允许一个线程执行同步代码块,可以保证线程的安全性,但是执行效率低</p>
<p>ReentrantReadWriteLock读写锁是一种改进的排他锁,也可以称作共享/排他锁,允许多个线程同时读取共享数据,但是一次只允许一个线程对共享数据进行更新</p>
<p>读写锁通过读锁与写锁来完成读写操作,线程在读取共享数据前必须先持有读锁,该读锁可以被多个线程持有,即它是共享的,线程在修改共享数据前必须先持有写锁,写锁是排他的</p>
<p>读锁只是在读线程之间共享,任何一个线程持有读锁时,其他线程都无法获得写锁,保证了线程在读取数据期间没有其他线程对数据进行更新,使得读线程能够读到数据的最新值,保证在读数据期间共享变量不被修改</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>获得条件</th>
<th>排他性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>读锁</td>
<td>写锁未被任意线程持有</td>
<td>对读线程是共享的,对写线程是排他的</td>
<td>允许多个读线程可以同时读取共享数据,保证在读共享数据时,没有其他线程对共享数据进行修改</td>
</tr>
<tr>
<td>写锁</td>
<td>该写锁未被其他线程持有,并且响应的读锁也未被其他线程持有</td>
<td>对读线程和写线程都是排他的</td>
<td>保证写线程以独占的方式修改共享数据</td>
</tr>
</tbody></table>
<p>在java.util.concurrent.locks包中定义了ReadWriteLock接口,该接口中定义了readLock()返回读锁,定义writeLock()方法返回写锁,该接口的实现类是ReentrantReadWriteLock</p>
<p><strong>注意readLock()与writeLock()方法返回的锁对象是同一个锁的两个不同的角色,不是分别获得两个不同的锁</strong>,ReadWriteLock接口实例可以充当两个角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义读写锁</span></span><br><span class="line">ReadWriteLock rwLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//获得读锁</span></span><br><span class="line">Lock readLock=rwLock.readLock();</span><br><span class="line"><span class="comment">//获得写锁</span></span><br><span class="line">Lock writeLock=rwLock.writeLock();</span><br></pre></td></tr></table></figure>

<h5 id="读读共享"><a href="#读读共享" class="headerlink" title="读读共享"></a>读读共享</h5><p>ReadWriteLock读写锁可以实现多个线程同时读取数据,即读读共享,可以提高程序的读取数据的效率</p>
<p>小例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义读写锁</span></span><br><span class="line">        ReadWriteLock readWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        <span class="comment">//定义方法读取数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                readWriteLock.readLock().lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获得读锁&quot;</span>+System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//模拟读取数据耗时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                readWriteLock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service service=<span class="keyword">new</span> Service();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; service.read()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821143804836.png" alt="image-20220821143804836"></p>
<h5 id="写写互斥"><a href="#写写互斥" class="headerlink" title="写写互斥"></a>写写互斥</h5><p>小例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义读写锁</span></span><br><span class="line">        ReadWriteLock readWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        <span class="comment">//定义方法模拟写数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                readWriteLock.writeLock().lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获得写锁&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//模拟读取数据耗时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                readWriteLock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service service=<span class="keyword">new</span> Service();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; service.write()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821144443967.png" alt="image-20220821144443967"></p>
<p>等待上一个线程释放写锁之后下一个线程才能得到写锁</p>
<h5 id="读写互斥"><a href="#读写互斥" class="headerlink" title="读写互斥"></a>读写互斥</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义读写锁</span></span><br><span class="line">        ReadWriteLock readWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        <span class="comment">//定义方法读取数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                readWriteLock.readLock().lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获得读锁&quot;</span>+System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//模拟读取数据耗时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                readWriteLock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                readWriteLock.writeLock().lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获得写锁&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//模拟读取数据耗时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                readWriteLock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service service=<span class="keyword">new</span> Service();</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; service.write()).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; service.read()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821144933171.png" alt="image-20220821144933171"></p>
<p>等待上一个写线程执行完毕释放写锁之后才能获得读锁</p>
<h2 id="6-线程管理"><a href="#6-线程管理" class="headerlink" title="6.线程管理"></a>6.线程管理</h2><h4 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h4><p>在线程组中定义一组相关(相似)的线程,在线程组中也可以定义子线程组</p>
<p>Thread类有几个构造方法允许在创建线程时执行线程组,如果在创建线城时没有执行线程组,那么该线程就属于父线程所在的线程组</p>
<p>JVM在创建main线程时会为它指定一个线程组,因此每个Java线程组都有一个线程组与它关联,可以调用线程的getThreadGroup()方法返回线程组</p>
<p>线程组开始是出于安全的考虑设计用来区分不同的Applet,然而ThreadGroup并未实现这一目标,在新开发的系统中,已经不常用线程组了</p>
<h5 id="线程组创建"><a href="#线程组创建" class="headerlink" title="线程组创建"></a>线程组创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回当前main线程的线程组</span></span><br><span class="line">        ThreadGroup mainGroup=Thread.currentThread().getThreadGroup();</span><br><span class="line">        System.out.println(mainGroup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义线程组,如果不指定所属线程组,则自动归属到当前线程所属的线程组中</span></span><br><span class="line">        ThreadGroup group1=<span class="keyword">new</span> ThreadGroup(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        System.out.println(group1);</span><br><span class="line">        System.out.println(group1.getParent()==mainGroup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义线程组,同时指定父线程组</span></span><br><span class="line">        ThreadGroup group2=<span class="keyword">new</span> ThreadGroup(mainGroup,<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">        System.out.println(group2.getParent()==mainGroup);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建线程时不指定线程组</span></span><br><span class="line">        Runnable r=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(r,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        System.out.println(t1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程时指定线程组</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(group1,r,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        System.out.println(t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821152550460.png" alt="image-20220821152550460"></p>
<h5 id="线程组的基本操作"><a href="#线程组的基本操作" class="headerlink" title="线程组的基本操作"></a>线程组的基本操作</h5><p>activeCount()返回当前线程组及子线程组中活动该线程的数量(近似)</p>
<p>activeGroupCount()返回当前线程组及子线程组中活动线程组的数量(近似值)</p>
<p>int enumerate(Thread[] list)将当前线程组中的活动线程复制到参数数组中</p>
<p>getMaxPriority()返回线程组的最大优先级,默认为10</p>
<p>getName()返回线程组名称</p>
<p>getParent()返回父线程组</p>
<p>interrupt()中断线程组中所有的线程</p>
<p>setDaemon(boolean daemon)设置线程组为守护线程组</p>
<p>isDaemon()判断当前线程组是否为守护线程组</p>
<p>list()将当前线程组中的活动线程打印出来</p>
<p>parentOf(ThreadGroup g)判断当前线程组是否为参数线程组的父线程组</p>
<h5 id="复制线程组中的线程及子线程组"><a href="#复制线程组中的线程及子线程组" class="headerlink" title="复制线程组中的线程及子线程组"></a>复制线程组中的线程及子线程组</h5><p>enumerate(Thread[] list)把当前线程组合子线程组中所有的线程复制到参数数组中</p>
<p>enumerate(Thread[] list，boolean recurse)第二个参数设置为false,则只复制当前线程组的子线程组</p>
<h5 id="线程组的批量中断"><a href="#线程组的批量中断" class="headerlink" title="线程组的批量中断"></a>线程组的批量中断</h5><p>线程组的interrupt()方法可以给该线程组中所有的活动线程添加中断标志</p>
<h5 id="设置守护线程组"><a href="#设置守护线程组" class="headerlink" title="设置守护线程组"></a>设置守护线程组</h5><p>守护线程是为其他线程提供服务的,当JVM中只有守护线程时,守护线程会自动销毁,JVM会退出</p>
<p>调用线程组的setDaemon(true)可以把线程组设置为守护线程组,<strong>当守护线程组中没有任何活动线程时,守护线程组会自动销毁</strong></p>
<p>注意线程组的守护属性,不影响线程组中线程的守护属性,或者说守护线程组中的线程可以是非守护线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//先定义线程组</span></span><br><span class="line">        ThreadGroup group=<span class="keyword">new</span> ThreadGroup(<span class="string">&quot;group&quot;</span>);</span><br><span class="line">        <span class="comment">//设置线程组为守护线程组</span></span><br><span class="line">        group.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//向组中添加3个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(group, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+j);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子中,main线程5秒结束,守护线程组中的非守护线程需要10秒结束,在main线程结束后,他们还是继续运行,直到三个线程都结束,守护线程组才自动销毁</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220821160517628.png" alt="image-20220821160517628"></p>
<h4 id="捕获线程的执行异常"><a href="#捕获线程的执行异常" class="headerlink" title="捕获线程的执行异常"></a>捕获线程的执行异常</h4><p>在线程的run()方法中,如果有受检异常必须进行捕获处理,如果想要获得run()方法中出现的运行时异常信息,可以通回调UncaughtExceptionHandler接口获得哪个线程出现了运行时异常,在Thread类中有关处理运行异常的方法有:</p>
<p><code>getDefultUncaughtExceptionHandler()</code>获得全局的(默认的)UncaughtExceptionHandler</p>
<p><code>getUncaughtExceptionHandler()</code>获得当前线程的UncaughtExceptionHandler</p>
<p><code>setDefultUncaughtExceptionHandler()</code>设置全局的UncaughtExceptionHandler</p>
<p><code>setUncaughtExceptionHandler()</code>设置当前线程的UncaughtExceptionHandler</p>
<h5 id="设置全局线程异常的回调接口"><a href="#设置全局线程异常的回调接口" class="headerlink" title="设置全局线程异常的回调接口"></a>设置全局线程异常的回调接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置线程异常全局的回调接口</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getName()+<span class="string">&quot;产生了异常:&quot;</span>+e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="number">10</span>/<span class="number">0</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822151634663.png" alt="image-20220822151634663"></p>
<p>如果设置了自己线程的UncaughtExceptionHandler就就调用自己的UncaughtExceptionHandler</p>
<p>没有则调用看全局UncaughtExceptionHandler</p>
<p>全局也没有就直接把异常栈信息定向到System.err中</p>
<h5 id="注入Hook钩子线程"><a href="#注入Hook钩子线程" class="headerlink" title="注入Hook钩子线程"></a>注入Hook钩子线程</h5><p>现在很多软件包括MySql,Zookeeper,kafka等都存在Hook线程的校验机制,目的是校验进程是否已启动,防止重复启动程序</p>
<p>Hook线程也称为钩子线程,当JVM退出的时候会执行Hook线程,经常在程序启动的时候创建一个.lock文件,用.lock文件校验程序是否启动,在程序退出(JVM退出)时删除该.lock文件,在Hook线程中除了防止重新启动进程外,还可以做资源释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.注入Hook线程,在程序退出时删除.lock文件</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;JVM退出,会启动柜当前hook线程,在hook线程中删除.lock文件&quot;</span>);</span><br><span class="line">                getLockFile().toFile().delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">//2.程序运行时,检查.lock文件是否存在,如果存在,则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(getLockFile().toFile().exists())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;程序已启动&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getLockFile().toFile().createNewFile();</span><br><span class="line">                System.out.println(<span class="string">&quot;程序启动并创建了.lock文件&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟程序运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序运行中----&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">getLockFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Paths.get(<span class="string">&quot;&quot;</span>,<span class="string">&quot;tmp.lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822154013314.png" alt="image-20220822154013314"></p>
<p>如果.lock文件没有删除运行则报错</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822154050264.png" alt="image-20220822154050264"></p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h5><p>线程池内部可以预先创建一定数量的工作线程,客户端代码直接将任务作为一个对象提交给线程池,线程池将这些任务缓存在工作队列中,线程池中的工作线程不断地从队列中取出任务</p>
<h5 id="JDK对线程池的支持"><a href="#JDK对线程池的支持" class="headerlink" title="JDK对线程池的支持"></a>JDK对线程池的支持</h5><p>JDK提供了一套Executor框架,可以帮助开发人员有效的使用线程池</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822160953591.png" alt="image-20220822160953591"></p>
<h5 id="线程池的基本使用"><a href="#线程池的基本使用" class="headerlink" title="线程池的基本使用"></a>线程池的基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建有5个线程大小的线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//向线程池中提交18个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getId()+<span class="string">&quot;号任务正在执行任务,开始时间:&quot;</span>+System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以5个为一轮,固定的5个线程执行任务</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822161546596.png" alt="image-20220822161546596"></p>
<h5 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h5><p>两个方法</p>
<h6 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h6><p>​    该方法执行后,线程池状态变为SHUTDOWN,不会接收新任务,但是会执行完已提交的任务,此方法不会阻塞调用线程的执行</p>
<p>shutdownNow()</p>
<p>​    该方法执行后,线程池状态变为STOP,不会接收新任务,会将队列中的任务返回,并用interrupt的方式中断正在执行的</p>
<h5 id="Execurors提供的线程池和特点"><a href="#Execurors提供的线程池和特点" class="headerlink" title="Execurors提供的线程池和特点"></a>Execurors提供的线程池和特点</h5><ol>
<li><code>newSingleThreadExecutor()</code> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
<li><code>newFixedThreadPool() </code>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li><code>newScheduledThreadPool() </code>创建一个可定期或者延时执行任务的定长线程池，支持定时及周期性任务执行。 </li>
<li><code>newCachedThreadPool()</code> 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 </li>
</ol>
<h5 id="核心线程池的底层实现"><a href="#核心线程池的底层实现" class="headerlink" title="核心线程池的底层实现"></a>核心线程池的底层实现</h5><p>查看Executors工具类中<code>newFixedThreadPool</code>,<code>newFixedThreadPool</code>,<code>newSingleThreadExecutor</code>等方法,都调用了<code>ThreadPoolExecutor</code>这个构造方法</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822163534233.png" alt="image-20220822163534233"></p>
<p>各个参数含义</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>指定线程池中核心线程的数量                                                                                       CPU 密集型： CPU 核数  + 1                                                               IO 密集型： 2 倍 CPU 核数 + 1</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>指定线程池中最大线程数量</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>当线程池中线程的数量超过corePoolSize时,多余的空闲线程的存活时长,即空闲线程在多长时长内销毁</td>
</tr>
<tr>
<td>unit</td>
<td>是keepAliveTime时长单位</td>
</tr>
<tr>
<td>wordQueue</td>
<td>任务队列,把任务提交到该任务队列中等待执行</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝策略,当任务太多来不及处理时,如何拒绝</td>
</tr>
</tbody></table>
<h6 id="wordQueue"><a href="#wordQueue" class="headerlink" title="wordQueue"></a>wordQueue</h6><p>workQueue工作队列是指提交未执行的任务队列,它是BlockingQueue接口的对象,仅用于存储Runnable任务,根据队列功能分类,在ThreadPoolExecutor构造方法中可以使用以下几种阻塞队列</p>
<p>1.直接提交队列</p>
<p>由<code>SynchronousQueue</code>对象提供,该队列没有容量,提交给线程池的任务不会被真实的保存,总是将新的任务提交给线程执行,如果没有空闲线程,则尝试创建新的线程,如果线程数量已经达到maximumPoolSize规定的最大值则执行拒绝策略</p>
<p>2.有界任务队列</p>
<p>由<code>ArrayBlockingQueue</code>实现,在创建<code>ArrayBlockingQueue</code>对象时,可以指定一个容量,当有任务需要执行时,如果线程池中线程数小于<code>corePoolSize</code>核心线程数则创建新的线程;如果大于<code>corePoolSize</code>核心线程数则加入等待队列;</p>
<p>如果队列已满则无法加入,在线程数小于<code>maximumPoolSize</code>指定的最大线程数前提下会创建新的线程来执行,如果线程数大于<code>maximumPoolSize</code>最大线程数则执行拒绝策略</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822172950757.png" alt="image-20220822172950757"></p>
<p>3.无界任务队列</p>
<p>由<code>LinkedBlockingQueue</code>对象实现,与有界队列相比,除非资源耗尽,否则无界队列不存在任务入队失败的情况,当有新的任务时,在系统线程数小于<code>corePoolSize</code>核心线程数则创建新的线程来执行任务;当线程池中线程数量大于<code>corePoolSize</code>核心线程数则把任务加入阻塞队列</p>
<p>4.优先任务队列</p>
<p>通过<code>PriorityBlockingQueue</code>实现,是带有任务优先级的队列,是一个特殊的无界队列,不管是<code>ArrayBlockingQueue</code>队列还是<code>LinkedBlockingQueue</code>队列都是按照先进先出算法处理任务的,在<code>PriorityBlockingQueue</code>中可以根据任务优先级顺序先后执行</p>
<h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p>当线程池中的线程用完了,等待队列也满了,无法为新提交的任务服务,可以通过拒绝策略来处理这个问题,jdk提供了四种拒绝策略</p>
<h6 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h6><p>抛出异常</p>
<h6 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h6><p>只要线程池没有关闭,它会在调用者线程中运行当前被丢弃的任务</p>
<h6 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h6><p>将队列中最老的任务(即将要执行的任务)丢弃,尝试再次提交新任务</p>
<h6 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h6><p>直接丢弃这个无法处理的任务</p>
<h5 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h5><p>ThreadFactory是一个接口,只有一个用来创建线程的方法:</p>
<p>Thread newThread(Runnable r);</p>
<p>当线程池中需要创建线程时就会调用该方法</p>
<h5 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h5><p>ThreadPoolExecutor提供了一组方法用于监控线程池</p>
<p>int getActiveCount()获得线程池中当前活动线程的数量</p>
<p>long getCompletedTaskCount()返回线程池完成任务的数量</p>
<p>int getCorePoolSize() 线程池中核心线程的数量</p>
<p>int getLargestPoolSize() 返回线程池曾经达到的线程的最大数</p>
<p>int getMaximumPoolSize()返回线程池的最大容量</p>
<p>int getPoolSize()返回当前线程池的大小</p>
<p>getQueue() 返回阻塞队列</p>
<p>long getTaskCount() 返回线程池收到的任务总数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//先定义任务</span></span><br><span class="line">        Runnable r=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+<span class="string">&quot;编号的线程开始执行: &quot;</span>+System.currentTimeMillis());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);<span class="comment">//线程睡眠10秒,模拟任务执行时长</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//定义线程池</span></span><br><span class="line">        ThreadPoolExecutor poolExecutor=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>, TimeUnit.SECONDS,<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>), Executors.defaultThreadFactory(),<span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向线程池提交30个任务</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            poolExecutor.submit(r);</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程池核心线程数量&quot;</span>+poolExecutor.getCorePoolSize()+<span class="string">&quot;,最大线程数&quot;</span>+poolExecutor.getMaximumPoolSize()+<span class="string">&quot;,当前线程池大小&quot;</span>+poolExecutor.getPoolSize()+<span class="string">&quot;,收到任务数量:&quot;</span>+poolExecutor.getTaskCount()+<span class="string">&quot;,完成任务数:&quot;</span>+poolExecutor.getCompletedTaskCount()+<span class="string">&quot;,等待任务数&quot;</span>+poolExecutor.getQueue().size());</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------提交完成-------------------&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">while</span> (poolExecutor.getActiveCount()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程池核心线程数量&quot;</span>+poolExecutor.getCorePoolSize()+<span class="string">&quot;,最大线程数&quot;</span>+poolExecutor.getMaximumPoolSize()+<span class="string">&quot;,当前线程池大小&quot;</span>+poolExecutor.getPoolSize()+<span class="string">&quot;,收到任务数量:&quot;</span>+poolExecutor.getTaskCount()+<span class="string">&quot;,完成任务数:&quot;</span>+poolExecutor.getCompletedTaskCount()+<span class="string">&quot;,等待任务数&quot;</span>+poolExecutor.getQueue().size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822191225957.png" alt="image-20220822191225957"></p>
<p>在提交完成后,只收到了15个任务,因为创建的线程池最大线程数为5,最大容量为5,同时等待队列最大容量为5,每半秒提交一个任务,所以30个总共耗时15秒,理论上来说15秒内后面15个线程都没地方可去,执行拒绝策略<code>DiscardPolicy</code>都将其抛弃</p>
<h5 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h5><p>有时需要对线程池进行扩展,如在监控每个任务的开始和结束时间,或者自定义一些其他增强的功能:</p>
<p>ThreadPoolExecutor线程池提供了两个方法:</p>
<p>afterExecute(),beforeExecute()</p>
<p>在线程池执行某个任务前会调用<code>beforeExecute()</code>,在任务结束后(任务异常退出)会调用<code>afterExecute()</code></p>
<p>查看<code>ThreadPoolExecutor</code>源码,在该类中定义了一个内部类Worker,ThreadPoolExecutor线程池中的工作线程就是Worker类的实例,Worker实例在执行时会调用<code>beforeExecute()</code>与<code>afterExecute()</code>方法</p>
<p>这种重写类似于Spring中的Filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;任务正在被线程&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 执行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义扩展线程池,可以定义线程池类继承ThreadPoolExecutor方法,在子类中重写beforeExecute()/afterExecute()方法</span></span><br><span class="line">        <span class="comment">//也可以直接使用ThreadPoolExecutor的内部类</span></span><br><span class="line">        ExecutorService executorService=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">0</span>, TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;())&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                System.out.println(t.getId()+<span class="string">&quot;线程准备执行任务&quot;</span>+((MyTask)r).name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(((MyTask)r).name+<span class="string">&quot;任务执行完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程池退出&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建5个任务添加到线程池中执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> MyTask(<span class="string">&quot;task--&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executorService.shutdown();<span class="comment">//关闭线程池仅仅是说线程池不再接收新的任务,线程池中已接收的任务正常执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220822232958662.png" alt="image-20220822232958662"></p>
<h5 id="优化线程池数量"><a href="#优化线程池数量" class="headerlink" title="优化线程池数量"></a>优化线程池数量</h5><p>线程池大小对系统性能是有一定影响的,过大或过小都会无法发挥最优的系统性能,线程池大小不需要非常精确,只要避免极大或者极小的情况即可</p>
<p><strong>线程池大小=CPU核心数量×目标CPU的使用率×(1+平均等待时间/平均工作时间)</strong></p>
<h5 id="线程池死锁"><a href="#线程池死锁" class="headerlink" title="线程池死锁"></a>线程池死锁</h5><p>如果在线程池中执行的任务A在执行过程中又向线程池提交了任务B,任务B添加到了线程池的等待队列中,如果任务A的结束需要等待任务B的执行结果,就有可能出现这种情况:<strong>线程池中所有的工作线程都处于等待任务处理结果,而这些任务在阻塞队列中等待执行</strong>,线程池中没有可以对阻塞队列中的任务进行处理的线程,这种等待会一直持续下去,从而造成死锁</p>
<p>   适合给线程池提交相互独立的任务,而不是批次依赖的任务,对于彼此依赖的任务,可以考虑分别提交给不同的线程池来执行</p>
<h5 id="线程池中的异常跟踪"><a href="#线程池中的异常跟踪" class="headerlink" title="线程池中的异常跟踪"></a>线程池中的异常跟踪</h5><p>直接使用原生的submit()方法往线程池添加任务,会将异常吞掉</p>
<ol>
<li>使用execute()添加任务</li>
<li>自定义ThreadPoolExecutor类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义方法,对执行的任务进行包装,接收两个参数,一个参数接收要执行的任务,另一个参数是Exception异常</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Runnable <span class="title">wrap</span><span class="params">(Runnable task,Exception exception)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            task.run();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            exception.printStackTrace();</span><br><span class="line">                            <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task,<span class="keyword">new</span> Exception(<span class="string">&quot;自定义跟踪异常&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            TraceThreadPoolExecutor traceThreadPoolExecutor = <span class="keyword">new</span> TraceThreadPoolExecutor(<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;&gt;());</span><br><span class="line">            traceThreadPoolExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">0</span>/<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220823000927977.png" alt="image-20220823000927977"></p>
<h5 id="ForkJoinPool线程池"><a href="#ForkJoinPool线程池" class="headerlink" title="ForkJoinPool线程池"></a>ForkJoinPool线程池</h5><p>该线程池采用的是”分治”思想</p>
<p>系统对ForkJoinPool线程池进行了优化,提交的任务数量与线程的数量不一定是一对一关系,在多数情况下,一个物理线程实际上需要处理多个逻辑任务</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220823105618999.png" alt="image-20220823105618999"></p>
<h6 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h6><p>求两个正整数之间所有数的合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD=<span class="number">10000</span>;<span class="comment">//阈值为10000</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASKNUM=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> start;<span class="comment">//计算数列的起始值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> end;<span class="comment">//计算数列的结束值</span></span><br><span class="line">        <span class="comment">//重写RecursiveTask类的compute()方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum=<span class="number">0</span>;<span class="comment">//保存计算的结果</span></span><br><span class="line">            <span class="comment">//判断任务是否需要继续分解,如果当前数列end与start范围的数超过阈值THRESHOLD,就需要继续分解</span></span><br><span class="line">            <span class="keyword">if</span>(end-start&lt;THRESHOLD)&#123;</span><br><span class="line">                <span class="comment">//小于阈值就直接计算</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                    sum+=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//数列范围超过阈值,需要继续分解</span></span><br><span class="line">                <span class="comment">//约定每次分解成100个小任务,计算每个任务的计算量</span></span><br><span class="line">                <span class="keyword">long</span> step=(end-start)/TASKNUM;</span><br><span class="line">                ArrayList&lt;CountTask&gt; subTaskList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">long</span> pos=start;<span class="comment">//每个任务的起始位置</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASKNUM; i++) &#123;</span><br><span class="line">                    <span class="keyword">long</span> lastOne=pos+step;<span class="comment">//每个任务的结束位置</span></span><br><span class="line">                    <span class="keyword">if</span>(lastOne&gt;end)&#123;<span class="comment">//调整最后一个任务的结束位置</span></span><br><span class="line">                        lastOne=end;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//创建子任务</span></span><br><span class="line">                    CountTask task=<span class="keyword">new</span> CountTask(pos,lastOne);</span><br><span class="line">                    <span class="comment">//把任务添加到集合中</span></span><br><span class="line">                    subTaskList.add(task);</span><br><span class="line">                    <span class="comment">//使用fork()提交子任务</span></span><br><span class="line">                    task.fork();</span><br><span class="line">                    <span class="comment">//调整下个任务的起始位置</span></span><br><span class="line">                    pos+=step+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待所有的子任务结束后,合并计算结果</span></span><br><span class="line">                <span class="keyword">for</span> (CountTask task:subTaskList)&#123;</span><br><span class="line">                    sum+=task.join();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建ForkJoinPool线程池</span></span><br><span class="line">        ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//创建一个大任务</span></span><br><span class="line">        CountTask task=<span class="keyword">new</span> CountTask(<span class="number">0</span>,<span class="number">2000000</span>);</span><br><span class="line">        <span class="comment">//把大任务提交给线程池</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; result=forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long res=result.get();<span class="comment">//调用任务的get()方法返回结果</span></span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总的来说,这个线程池的用法有点类似递归的写法,和递归一样,什么时候继续向下调用方法,是问题的关键</strong></p>
<h2 id="7-保障线程安全的设计技术"><a href="#7-保障线程安全的设计技术" class="headerlink" title="7.保障线程安全的设计技术"></a>7.保障线程安全的设计技术</h2><h4 id="java运行时存储空间"><a href="#java运行时存储空间" class="headerlink" title="java运行时存储空间"></a>java运行时存储空间</h4><p>Java运行时空间可以分为栈区,堆区与方法区(非堆空间)</p>
<p>​    栈空间为线程的执行准备一段固定大小的存储空间,每个线程都有独立的线程栈空间,创建线城时就为线程分配栈空间,在线程栈中每调用一个方法就给方法分配一个<strong>栈帧</strong>,栈帧用于存储方法的局部变量,返回值等私有数据,即<strong>局部变量存储在栈空间中</strong>,基本类型变量也是存储在栈空间中,引用类型变量值也是存储在栈空间中,引用的对象存储在堆中,由于线程栈是相互独立的,一个线程不能访问另外一个线程的栈空间,因此线程对局部变量以及只能通过当前线程的局部变量才能访问的对象进行的操作具有固定的线程安全性.</p>
<p>​    栈空间用于存储对象,是在JVM启动时分配的一段可以动态扩容的内存空间,创建对象时,在堆空间中给对象分配存储空间,实例变量就是存储在堆空间中的,对空间是多个线程之间可以共享的空间,因此实例变量可以被多个线程共享,多个线程同时操作实例变量可以存在线程安全问题</p>
<p>​    非堆空间用于存储常量,类的元数据等,非堆空间也是在JVM启动时分配的一段可以动态扩容的存储空间,类的元数据包括静态变量,类有哪些方法以及这些方法的元数据(方法名,参数,返回值等),非堆空间也是多个线程可以共享的,因此访问非堆空间中的静态变量也可能存在线程安全问题.</p>
<p>​    ==不被其他线程共享的空间具有固有的局部安全性==</p>
<h4 id="无状态对象"><a href="#无状态对象" class="headerlink" title="无状态对象"></a>无状态对象</h4><p><strong>通俗来讲,无状态对象就是没有变量的对象</strong></p>
<p>​    对象就是数据及对数据操作的封装,对象所包含的数据称为对象的状态(state),实例变量与静态变量称为状态变量</p>
<p>​    如果一个类的同一个实例被多个线程共享并不会使这些线程存储共享的状态,那么该类的实例就称为无状态对象(Stateless Object),反之,如果一个类的实例被多个线程共享会使这些线程存在共享状态,那么该类的实例称为有状态对象,<strong>实际上无状态对象就是不包含任何实例变量的对象,也不包含任何静态变量</strong></p>
<p>​    线程安全问题的前提是多个线程存在共享的数据,实现线程安全的一种办法就是避免在多个线程之间共享数据,使用无状态对象就是这种方法</p>
<h4 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h4><p>​    不可变对象是指一经创建它的状态(数据)就保持不变的对象,不可变对象也具有固有的线程安全性,当不可变对象现实实体的状态发生变化时,系统会创建一个新的不可变对象,就如<strong>String字符串对象</strong></p>
<h5 id="一个不可变对象需要满足以下条件"><a href="#一个不可变对象需要满足以下条件" class="headerlink" title="一个不可变对象需要满足以下条件:"></a><strong>一个不可变对象需要满足以下条件:</strong></h5><ol>
<li>类本身使用final修饰,防止通过创建子类来改变它的定义</li>
<li>所有字段都是final修饰的,final在创建对象时必须显示初始化,不能被修改</li>
<li>如果字段引用了其他状态可变的对象(集合,数组),则这些字段必须是private私有的</li>
</ol>
<p>频繁创建不可变对象可能会提升GC的负担</p>
<h5 id="不可变对象的主要应用场景"><a href="#不可变对象的主要应用场景" class="headerlink" title="不可变对象的主要应用场景"></a>不可变对象的主要应用场景</h5><ul>
<li>被创建的对象的状态变化不频繁</li>
<li>同时对一组相关数据进行写操作,可以应用不可变对象,既可以保障原子性也可以避免锁的使用</li>
<li>使用不可变对象作为安全可靠的Map键,HashMap键值对的存储位置与键的hashCode有关,如果键的内部状态发生了变化会导致键的hashCode不同,可能会影响键值对的存储位置,如果HashMap的键是一个不可变对象,则hashCode()方法的返回值恒定,存储位置是固定的</li>
</ul>
<h4 id="线程特有对象"><a href="#线程特有对象" class="headerlink" title="线程特有对象"></a>线程特有对象</h4><p>​    我们可以选择不共享非线程安全的对象,对于非线程安全的对象,每个线程都创建一个该对象的实例,各个线程访问各自创建的实例,一个线程不能访问另外一个线程创建的实例,这种各个线程创建各自的实例,一个实例只能被线程访问的对象就称为线程特有对象.</p>
<p>​    线程特有对象既保障了对线程安全对象的访问的线程安全,又避免了锁的开销,<strong>线程特有对象也具有固有的线程安全性</strong></p>
<p><code>ThreadLocal&lt;T&gt;</code>类就相当于线程访问其特有对象的代理,即各个线程通过ThreadLocal对象可以创建并访问各自的线程特有对象,泛型T指定了线程特有对象的类型,一个线程可以使用不同的ThreadLocal实例来创建并访问不同的线程特有对象</p>
<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>​    装饰器模式可以用来实现线程安全,基本思想是为非线程安全的对象创建一个相应的线程安全的外包装对象,客户端代码不直接访问非线程安全的对象而是访问它的外包装对象.外包装对象与非线程安全的对象具有相同的接口,即外包装对象的使用方式与非线程安全的对象的使用方式相同,而外包装对象内部通常会借助锁,以线程安全的方式调用相应的非线程安全对象的方法</p>
<p>​    在java.util.Collections工具类中提供了一组synchronizedXXX(xxx)方法可以把不是线程安全的xxx集合转换为线程安全的集合,它就是采用了这种装饰器模式,这个方法返回值就是指定集合的外包装对象,这类集合又称为同步集合.</p>
<p><img src="https://picture-1304716932.cos.ap-chengdu.myqcloud.com/img/image-20220823123326082.png" alt="image-20220823123326082"></p>
<p>​    使用装饰器模式的一个好处就是实现关注点分离,在这种设计中,实现同一组功能的对象的两个版本:非线程安全的对象与线程安全的对象.</p>
<p>​    对于非线程安全的在设计时只关注要实现的功能,对于线程安全版本的只关注线程安全性</p>
<h2 id="8-锁的优化及注意事项"><a href="#8-锁的优化及注意事项" class="headerlink" title="8.锁的优化及注意事项"></a>8.锁的优化及注意事项</h2><h3 id="有助于提高锁性能的几点建议"><a href="#有助于提高锁性能的几点建议" class="headerlink" title="有助于提高锁性能的几点建议"></a>有助于提高锁性能的几点建议</h3><h4 id="1-减少锁持有时间"><a href="#1-减少锁持有时间" class="headerlink" title="1.减少锁持有时间"></a>1.减少锁持有时间</h4><p>​    对于使用锁进行并发控制的应用程序来说,如果单个线程持有锁的时间过长,会导致锁的竞争更加激烈,会影响系统的性能,在程序中需要尽可能减少线程对锁的持有时间,如下面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">	otherCode1();</span><br><span class="line">	mutexMethod();</span><br><span class="line">	otherCode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在syncMethod同步方法中,假设只有mutexMethod()方法是需要同步的,otherCode1()与otherCode2()方法不需要进行同步,如果otherCode1()与otherCode2()这两个方法需要花费较长的cpu时间,在并发量较大的情况下,这种同步方案会导致等待线程的大量增加.一个较好的优化方案是,只在必要时进行同步,可以减少锁的持有时间,挺高系统的吞吐量,如把上面的代码改为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">	otherCode1();</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        mutexMethod();</span><br><span class="line">    &#125;</span><br><span class="line">	otherCode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只对<code>mutexMethod()</code>进行同步</p>
<h4 id="2-减少锁的粒度"><a href="#2-减少锁的粒度" class="headerlink" title="2.减少锁的粒度"></a>2.减少锁的粒度</h4><p>​    一个锁保护的共享数据的数量大小称为锁的粒度,如果一个锁保护的共享数据的数据量大就称该锁的粒度粗</p>
<p>锁的粒度过粗会导致线程在申请锁时需要进行不必要的等待,减少锁粒度是一种削弱多线程竞争的一种手段</p>
<p>​    在JDK7前,<code>java.util.cocurrent.ConcurrentHashMap</code>类采用分段锁协议,可以提高程序的并发性</p>
<h4 id="3-使用读写分离锁代替独占锁"><a href="#3-使用读写分离锁代替独占锁" class="headerlink" title="3.使用读写分离锁代替独占锁"></a>3.使用读写分离锁代替独占锁</h4><p>​    使用<code>ReadWriteLock</code>读写分离锁可以提高系统的性能,使用读写分离锁也是减小锁粒度的一种特殊情况.</p>
<p>​    读写锁是对系统功能点的分割,<strong>尤其是在读多于锁的情况下,对性能提升明显</strong></p>
<h4 id="4-锁分离"><a href="#4-锁分离" class="headerlink" title="4.锁分离"></a>4.锁分离</h4><p>​    将读写锁的思想进一步延伸就是锁分离.读写锁是根据读写操作功能上的不同进行了锁分离.根据应用程序功能的特点,也可以对独占锁进行分离,如<code>java.util.concurrent.LinkBlockingQueue</code>类中<code>take()</code>与<code>put()</code>方法分别是从队头取数据,把数据添加到队尾</p>
<p>​    虽然这两个方法都是对队列进行修改操作,由于操作的主体是链表,take()操作的是链表的头部,put()操作的是链表的尾部,两者并不冲突,如果采用独占锁的话,这两个操作不能同时并发,在该类中就采用锁分离,take()取数据时有取锁,put()添加数据时有自己的添加锁,这样take()与put()相互独立实现了并发</p>
<h4 id="5-锁粗化"><a href="#5-锁粗化" class="headerlink" title="5.锁粗化"></a>5.锁粗化</h4><p>​    为了保证多线程间的有效并发,会要求每个线程持有锁的时间尽量短,但是凡事都有一个度,如果对同一个锁不断的进行请求,同步和释放,也会消耗额外的资源,如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">		同步代码块<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        同步代码块<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM在遇到一连串不断对同一个锁进行请求和释放操作时,会把所有的锁整合成对锁的一次请求,从而减少对锁的请求次数,这个操作叫锁的粗化,如上一段代码会整合为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">		同步代码块<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        同步代码块<span class="number">2</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在开发过程中,也应该有意识的在合理的场合进行锁的粗化,尤其在循环体内请求锁时</strong></p>
<h3 id="JVM对锁的优化"><a href="#JVM对锁的优化" class="headerlink" title="JVM对锁的优化"></a>JVM对锁的优化</h3><h4 id="1-锁偏向"><a href="#1-锁偏向" class="headerlink" title="1.锁偏向"></a>1.锁偏向</h4><p>​    锁偏向是一种针对加锁操作的优化,如果一个线程获得了锁,那么锁就进入偏向模式,当这个线程再次请求锁时,无需再做任何同步操作,这样可以节省有关锁申请的时间,提高了程序的性能.</p>
<p>​    锁偏向在没有锁竞争的场合可以有较好的优化效果,对于锁竞争比较激烈的场景,效果不佳,锁竞争激烈的情况下可能每次都是不同的线程来请求锁,这时偏向模式失效.</p>
<h4 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2.轻量级锁"></a>2.轻量级锁</h4><p>​    如果锁偏向失败,JVM不会立即挂起线程,还会使用一种称为轻量级锁的优化手段,会将共享对象的头部作为指针,指向持有锁的线程堆栈内部,来判断一个线程是否持有对象锁,如果线程获得轻量级锁成功,就进入临界区,如果获得轻量级锁失败,表示其他线程抢到了锁,那么当前线程的锁的请求就膨胀为重量级锁,当前线程就转到阻塞队列中变为阻塞状态</p>
<p>​    偏向锁,轻量级锁都是乐观锁,重量级锁是悲观锁</p>
<p>​    一个对象刚开始实例化时,没有任何线程访问它,它是可偏向的,即它任务只可能有一个线程来访问它,所以当第一个线程来访问它的时候,它会偏向这个线程,偏向第一个线程,这个线程在修改对象搜称为偏向锁时使用CAS操作,将对象头中ThreadId改为自己的Id,之后再访问这个对象时,只需要对比id即可,一旦有第二个线程访问该对象,因为偏向锁不会主动释放,所以第二个线程可以查看对象的偏向状态,当第二个线程访问对象时,表示在这个对象上已经存在竞争了,检查原来持有对象锁的线程是否存活,如果挂了则将对象变为无锁状态,然后重新偏向新的线程,如果原来的线程依然存活,则马上执行原来线程的操作栈,检查该对象的使用情况,如果仍然需要偏向锁,则偏向锁升级为轻量级锁.</p>
<p>​    轻量级锁认为竞争存在,但是竞争的程度很轻,一般两个线程对同一个锁的操作会错开,或者稍微等待一下(自旋)另外一个线程就会释放锁.又来第三个线程访问时,轻量级锁会膨胀为重量级锁,重量级锁除了持有锁的线程外,其他的线程都阻塞.</p>
<p>[TOC]</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/18/%E8%83%8C%E5%BF%98%E5%BD%95%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" rel="prev" title="背忘录项目开发记录">
      <i class="fa fa-chevron-left"></i> 背忘录项目开发记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/26/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8%E8%AE%B0%E5%BD%95/" rel="next" title="java多线程下载器">
      java多线程下载器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">多线程学习记录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">1.线程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.1.</span> <span class="nav-text">线程的常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#currentThread%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.1.0.1.</span> <span class="nav-text">currentThread方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isAlive"><span class="nav-number">1.1.1.0.2.</span> <span class="nav-text">isAlive()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sleep"><span class="nav-number">1.1.1.0.3.</span> <span class="nav-text">sleep()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#getId"><span class="nav-number">1.1.1.0.4.</span> <span class="nav-text">getId()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#yield"><span class="nav-number">1.1.1.0.5.</span> <span class="nav-text">yield()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setPriority-num"><span class="nav-number">1.1.1.0.6.</span> <span class="nav-text">setPriority(num)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#interrupt"><span class="nav-number">1.1.1.0.7.</span> <span class="nav-text">interrupt()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setDaemon"><span class="nav-number">1.1.1.0.8.</span> <span class="nav-text">setDaemon()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E9%A3%8E%E9%99%A9"><span class="nav-number">1.1.3.</span> <span class="nav-text">多线程存在的问题与风险</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B4%BB%E6%80%A7"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">线程活性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81-Deadlock"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">死锁(Deadlock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E6%AD%BB-Lockout"><span class="nav-number">1.1.3.2.2.</span> <span class="nav-text">锁死(Lockout)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BB%E9%94%81-Livelock"><span class="nav-number">1.1.3.2.3.</span> <span class="nav-text">活锁(Livelock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A5%A5%E9%A5%BF-starvation"><span class="nav-number">1.1.3.2.4.</span> <span class="nav-text">饥饿(starvation)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">可靠性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.</span> <span class="nav-text">2.线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">原子性(Atomic)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7-visibility"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">可见性(visibility)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7-Ordering"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">有序性(Ordering)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.0.3.1.</span> <span class="nav-text">重排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F%E6%9C%89%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.0.3.2.</span> <span class="nav-text">与内存操作顺序有关的几个概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B2%8C%E4%BC%BC%E4%B8%B2%E8%A1%8C%E8%AF%AD%E4%B9%89"><span class="nav-number">1.2.0.3.3.</span> <span class="nav-text">貌似串行语义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-number">1.2.0.3.4.</span> <span class="nav-text">保证内存访问的顺序性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">1.2.1.</span> <span class="nav-text">内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">1.3.</span> <span class="nav-text">3.线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">锁概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">锁相关的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-number">1.3.1.1.1.</span> <span class="nav-text">可重入性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E4%BA%89%E7%94%A8%E4%B8%8E%E8%B0%83%E5%BA%A6"><span class="nav-number">1.3.1.1.2.</span> <span class="nav-text">锁的争用与调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="nav-number">1.3.1.1.3.</span> <span class="nav-text">锁的粒度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E9%94%81synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.3.1.1.4.</span> <span class="nav-text">内部锁synchronized关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%8F%E8%AF%BB"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">脏读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">线程出现异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">轻量级同步机制:volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#volatile%E4%B8%8Esynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%AF%94%E8%BE%83"><span class="nav-number">1.3.2.0.1.</span> <span class="nav-text">volatile与synchronized关键字比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#volatile%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.3.2.0.2.</span> <span class="nav-text">volatile不能保证原子性的例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-Compare-And-Swap-%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.3.</span> <span class="nav-text">CAS(Compare And Swap)原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">原子变量类概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AtomicIntegerFieldUpdater"><span class="nav-number">1.3.3.1.1.</span> <span class="nav-text">AtomicIntegerFieldUpdater</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AtomicReference%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.3.1.2.</span> <span class="nav-text">AtomicReference可能会出现CAS的ABA问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AtomicStampReference%E4%B8%AD%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9D%A5%E8%A7%A3%E5%86%B3ABA%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.3.1.3.</span> <span class="nav-text">使用AtomicStampReference中的版本号来解决ABA问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">1.4.</span> <span class="nav-text">4.线程间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">等待&#x2F;通知机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.4.0.1.1.</span> <span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-wait"><span class="nav-number">1.4.0.2.1.</span> <span class="nav-text">Object#wait()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-notify"><span class="nav-number">1.4.0.2.2.</span> <span class="nav-text">Object#notify()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#notify%E4%B8%8D%E4%BC%9A%E7%AB%8B%E5%8D%B3%E9%87%8A%E6%94%BE%E9%94%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.0.2.3.</span> <span class="nav-text">notify不会立即释放锁对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#interrupt-%E6%96%B9%E6%B3%95%E4%BC%9A%E4%B8%AD%E6%96%ADwait"><span class="nav-number">1.4.0.2.4.</span> <span class="nav-text">interrupt()方法会中断wait()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#notify-%E4%B8%8EnotifyAll"><span class="nav-number">1.4.0.2.5.</span> <span class="nav-text">notify()与notifyAll()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E7%9F%A5%E8%BF%87%E6%97%A9"><span class="nav-number">1.4.0.2.6.</span> <span class="nav-text">通知过早</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#wait%E6%9D%A1%E4%BB%B6%E5%8F%91%E7%94%9F%E4%BA%86%E5%8F%98%E5%8C%96"><span class="nav-number">1.4.0.2.7.</span> <span class="nav-text">wait条件发生了变化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">生产者消费者设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number">1.4.0.3.1.</span> <span class="nav-text">模拟栈</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">1.4.0.4.</span> <span class="nav-text">通过管道实现线程间的通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">ThreadLocal的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Lock%E6%98%BE%E7%A4%BA%E9%94%81"><span class="nav-number">1.5.</span> <span class="nav-text">5.Lock显示锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">锁的可重入性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.0.2.1.</span> <span class="nav-text">ReentrantLock的基本使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-number">1.5.0.2.2.</span> <span class="nav-text">ReentrantLock的可重入性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lockInterruptibly"><span class="nav-number">1.5.0.2.3.</span> <span class="nav-text">lockInterruptibly()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lockInterruptibly-%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.0.2.4.</span> <span class="nav-text">lockInterruptibly()可以解决死锁问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trylock-%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.0.2.5.</span> <span class="nav-text">trylock()方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#trylock-long-time-TimeUnit-unit"><span class="nav-number">1.5.0.2.5.1.</span> <span class="nav-text">trylock(long time,TimeUnit unit)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#trylock"><span class="nav-number">1.5.0.2.5.2.</span> <span class="nav-text">trylock()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#trylock-%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.5.0.2.5.3.</span> <span class="nav-text">trylock()可以避免死锁</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#newCondition-%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.0.2.6.</span> <span class="nav-text">newCondition()方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AACondition%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%9F%A5%E9%83%A8%E5%88%86%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.5.0.2.6.1.</span> <span class="nav-text">使用多个Condition对象实现通知部分线程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Condition%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0"><span class="nav-number">1.5.0.2.6.2.</span> <span class="nav-text">使用Condition实现多线程交替打印</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">1.5.0.2.7.</span> <span class="nav-text">公平锁与非公平锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.0.2.8.</span> <span class="nav-text">ReentrantLock几个常用的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#int-getHoldCount"><span class="nav-number">1.5.0.2.8.1.</span> <span class="nav-text">int getHoldCount()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#int-getQueueLength"><span class="nav-number">1.5.0.2.8.2.</span> <span class="nav-text">int getQueueLength()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#int-getWaitQueueLength-Condition-condition"><span class="nav-number">1.5.0.2.8.3.</span> <span class="nav-text">int getWaitQueueLength(Condition condition)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#hasQueuedThread-Thread-thread"><span class="nav-number">1.5.0.2.8.4.</span> <span class="nav-text">hasQueuedThread(Thread thread)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#hasQueuedThreads"><span class="nav-number">1.5.0.2.8.5.</span> <span class="nav-text">hasQueuedThreads()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#boolean-hasWaiters-Condition-condition"><span class="nav-number">1.5.0.2.8.6.</span> <span class="nav-text">boolean hasWaiters(Condition condition)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#boolean-isFair"><span class="nav-number">1.5.0.2.8.7.</span> <span class="nav-text">boolean isFair()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#boolean-isHeldByCurrentThread"><span class="nav-number">1.5.0.2.8.8.</span> <span class="nav-text">boolean isHeldByCurrentThread()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#boolean-islocked"><span class="nav-number">1.5.0.2.8.9.</span> <span class="nav-text">boolean islocked()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">ReentrantReadWriteLock读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E8%AF%BB%E5%85%B1%E4%BA%AB"><span class="nav-number">1.5.0.3.1.</span> <span class="nav-text">读读共享</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E5%86%99%E4%BA%92%E6%96%A5"><span class="nav-number">1.5.0.3.2.</span> <span class="nav-text">写写互斥</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E4%BA%92%E6%96%A5"><span class="nav-number">1.5.0.3.3.</span> <span class="nav-text">读写互斥</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text">6.线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">线程组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.6.0.1.1.</span> <span class="nav-text">线程组创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.0.1.2.</span> <span class="nav-text">线程组的基本操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="nav-number">1.6.0.1.3.</span> <span class="nav-text">复制线程组中的线程及子线程组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%9A%84%E6%89%B9%E9%87%8F%E4%B8%AD%E6%96%AD"><span class="nav-number">1.6.0.1.4.</span> <span class="nav-text">线程组的批量中断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="nav-number">1.6.0.1.5.</span> <span class="nav-text">设置守护线程组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">捕获线程的执行异常</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E7%9A%84%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.6.0.2.1.</span> <span class="nav-text">设置全局线程异常的回调接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5Hook%E9%92%A9%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.0.2.2.</span> <span class="nav-text">注入Hook钩子线程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.6.0.3.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.6.0.3.1.</span> <span class="nav-text">什么是线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">1.6.0.3.2.</span> <span class="nav-text">JDK对线程池的支持</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">1.6.0.3.3.</span> <span class="nav-text">线程池的基本使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD"><span class="nav-number">1.6.0.3.4.</span> <span class="nav-text">线程池的关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#shutdown"><span class="nav-number">1.6.0.3.4.1.</span> <span class="nav-text">shutdown()</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Execurors%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-number">1.6.0.3.5.</span> <span class="nav-text">Execurors提供的线程池和特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.0.3.6.</span> <span class="nav-text">核心线程池的底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wordQueue"><span class="nav-number">1.6.0.3.6.1.</span> <span class="nav-text">wordQueue</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">1.6.0.3.7.</span> <span class="nav-text">拒绝策略</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AbortPolicy"><span class="nav-number">1.6.0.3.7.1.</span> <span class="nav-text">AbortPolicy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CallerRunsPolicy"><span class="nav-number">1.6.0.3.7.2.</span> <span class="nav-text">CallerRunsPolicy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#DiscardOldestPolicy"><span class="nav-number">1.6.0.3.7.3.</span> <span class="nav-text">DiscardOldestPolicy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#DiscardPolicy"><span class="nav-number">1.6.0.3.7.4.</span> <span class="nav-text">DiscardPolicy</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadFactory"><span class="nav-number">1.6.0.3.8.</span> <span class="nav-text">ThreadFactory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.6.0.3.9.</span> <span class="nav-text">监控线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.6.0.3.10.</span> <span class="nav-text">扩展线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B0%E9%87%8F"><span class="nav-number">1.6.0.3.11.</span> <span class="nav-text">优化线程池数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%AD%BB%E9%94%81"><span class="nav-number">1.6.0.3.12.</span> <span class="nav-text">线程池死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E8%B7%9F%E8%B8%AA"><span class="nav-number">1.6.0.3.13.</span> <span class="nav-text">线程池中的异常跟踪</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinPool%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.6.0.3.14.</span> <span class="nav-text">ForkJoinPool线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%8F%E4%BE%8B%E5%AD%90"><span class="nav-number">1.6.0.3.14.1.</span> <span class="nav-text">小例子</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%BF%9D%E9%9A%9C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF"><span class="nav-number">1.7.</span> <span class="nav-text">7.保障线程安全的设计技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">java运行时存储空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">无状态对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.7.0.3.</span> <span class="nav-text">不可变对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E4%BB%A5%E4%B8%8B%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.7.0.3.1.</span> <span class="nav-text">一个不可变对象需要满足以下条件:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.7.0.3.2.</span> <span class="nav-text">不可变对象的主要应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%89%B9%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.7.0.4.</span> <span class="nav-text">线程特有对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.7.0.5.</span> <span class="nav-text">装饰器模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.8.</span> <span class="nav-text">8.锁的优化及注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%8A%A9%E4%BA%8E%E6%8F%90%E9%AB%98%E9%94%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.8.1.</span> <span class="nav-text">有助于提高锁性能的几点建议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%87%8F%E5%B0%91%E9%94%81%E6%8C%81%E6%9C%89%E6%97%B6%E9%97%B4"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">1.减少锁持有时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%87%8F%E5%B0%91%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">2.减少锁的粒度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E9%94%81%E4%BB%A3%E6%9B%BF%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">3.使用读写分离锁代替独占锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%94%81%E5%88%86%E7%A6%BB"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">4.锁分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">1.8.1.5.</span> <span class="nav-text">5.锁粗化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%AF%B9%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">1.8.2.</span> <span class="nav-text">JVM对锁的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%94%81%E5%81%8F%E5%90%91"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">1.锁偏向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">2.轻量级锁</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="blueSatchel"
      src="/../images/avatar.PNG">
  <p class="site-author-name" itemprop="name">blueSatchel</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bluesatchel" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bluesatchel" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">blueSatchel</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Aps2pGDp4GmAT5ebqUw6RUat-gzGzoHsz',
      appKey     : 'mikzA3qOg4gHjM10U4N8h52T',
      placeholder: "来说两句吧呜呜呜",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
