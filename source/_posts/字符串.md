---
title: 字符串
date: 2024-09-28 20:53:23
tags: 
      -c++
      - 算法
catrgories: leetcode
---

# 字符串

#### [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

最简单的一题,用双指针操作就行

```cpp
void reverseString(vector<char>& s) {
        char temp;
        int i = 0;
        int j = s.size() - 1;
        while (i < j) {
            temp = s[i];
            s[i] = s[j];
            s[j] = temp;
            i++;
            j--;
        }
    }
```



#### [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

本题对反转字符串有了新的规则

打破一个传统思想:字符串并不一定要逐个遍历其中的字符,也可以跳着遍历

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.length();
        int end = 0;
        for (int i = 0; i < n; i += 2 * k) {
            if (i + k < n) {
                //判断剩下的够不够k个
                myReverse(s, i, i + k - 1);
            } else {
                myReverse(s, i, n - 1);
            }
        }
        return s;
    }
    void myReverse(string& s, int begin, int end) {
        int i = begin;
        int j = end; // 下标
        while (i < j) {
            swap(s[i], s[j]);
            i++;
            j--;
        }
    }
};
```

#### [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

本题有两个关键点

1. 消去不合法空格的处理逻辑
2. 对合法字符串整体反转,再对每个单词进行翻转,就得到了反着的句子

```cpp
string reverseWords(string s) {
        int n = s.length();
        int flag = 0;//flag用于标识是否遍历到第一个字符用于消去字符串前置空格
        string temp = "";
        for (int i = 0; i < n; i++) {
            if (s[i] == ' ') {
                if (flag != 0) {
                    if (i < n - 1 && s[i + 1] != ' ') {
                        temp += s[i];
                    }
                }
            } else {
                flag = 1;
                temp += s[i];
            }
        }
        // temp就是去掉不合法空格之后的s
        reverse(temp.begin(), temp.end());
        int start = 0;
        for (int i = 0; i < temp.length(); i++) {
            if (temp[i] == ' ') {
                //反转每个单词    (这里的reverse是左闭右开)
                reverse(temp.begin() + start, temp.begin() + i);
                //记录下一个单词的开始位置
                start = i + 1;
            }
        }
        //因为前面检测的是空格,所以最后有可能会剩一个单词,单独处理一下它的反转
        if(start<n){
            reverse(temp.begin() + start, temp.end());
        }
        return temp;
    }
```

#### [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

##### 暴力解法

```cpp
bool repeatedSubstringPattern(string s) {
        bool res = false;
        for (int i = 0; i < s.size() / 2; i++) {
            // i获取子串结束位置
            int len = i - 0 + 1;
            int k = 1;//k表示当前循环了几个子串的长度,并用于后面计算j和子串之间的位置关系
            int count = 0;//用于计数以更新k
            for (int j = i + 1; j < s.size(); j++) {
                if (s[j] == s[j - k * len]) {
                    count++;
                    if (count % len == 0) {
                        k++;
                        if (j == s.size() - 1) {
                            res = true;
                        }
                    }
                }else{
                    //重新选子串
                    break;
                }
            }
        }
        return res;
    }
```

##### kmp解法



