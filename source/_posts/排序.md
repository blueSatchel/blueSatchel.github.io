---
title: 排序
date: 2024-10-04 16:46:10
tags:
	  - 排序
	  - 算法
	  - 考研

---

# 排序

考研复习的时候学习了各种内部排序的原理,在这里代码实现一下

### 插入排序

#### 直接插入排序

关键点是维护一个有序序列,这里循环从1开始,默认i之前的为有序序列,时间复杂度为O(N²)

```cpp
void insertSort(vector<int>&arr){
    for(int i=1;i<arr.size();i++){
        int j=i;
        while(arr[j]<arr[j-1]&&j>=1){
            int temp=arr[j];
            arr[j]=arr[j-1];
            arr[j-1]=temp;
            j--;
        }
    }
    //输出结果
    for(int i=0;i<arr.size();i++){
        printf("%d ",arr[i]);

    }
}
```



#### 折半插入排序

这里比较有意思的就是二分查找插入位置的代码,因为要插入的元素在数组中不存在,所以用left记录了最后一次划分的右区间的开头,也就是插入位置

```cpp
void binaryInsertSort(vector<int> &arr) {
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] < arr[i - 1]) {
            //说明需要往前面插入了,利用折半查找找到要插入的位置
            int temp = arr[i];
            int left = 0;
            int right = i - 1;
            int mid = 0;
            while (left <= right) {
                mid = (left + right) / 2;
                if (arr[mid] > temp) {
                    right = mid - 1;
                } else {
                    //插入右半表
                    left = mid + 1;
                }
            }
            //最后插入的位置就是右半表的第一个元素
            //后移比temp大的
            for (int j = i; j > left; j--) {
                arr[j] = arr[j - 1];
            }
            arr[left] = temp;
        }
    }
    //输出结果
    for (int i = 0; i < arr.size(); i++) {
        printf("%d ", arr[i]);

    }
}
```





#### 希尔排序

时间复杂度约为`O(N的1.3次方)~O(N²)`

```cpp
void shellSort(vector<int> &arr) {

    //这里假设增量d最开始为5
    int d=5;
    while(d){
        for(int i=d;i<arr.size();i++){
         //这里类比插入排序,插入排序从1开始,这里就从每一组的第二个元素开始
         int j=i;
         while(arr[j]<arr[j-d]&&j>=d){
             //从后往前,每次跳d个进行比较,同时要保证j-d>=0也就是j>=d
             int temp=arr[j];
             arr[j]=arr[j-d];
             arr[j-d]=temp;
             j-=d;
         }
        }
        d/=2;
    }
    //输出结果
    for (int i = 0; i < arr.size(); i++) {
        printf("%d ", arr[i]);

    }
}
```



### 交换排序

#### 冒泡排序

代码很简单,注意i和j的边界问题即可

还有就是可以设置一个flag变量,记录每一轮有没有发生交换,若没有发生交换则说明已经有序了,就可以直接结束了

```cpp
void bubbleSort(vector<int> &arr) {
    int flag = 0;
    for (int i = arr.size() - 1; i >= 0; i--) {
        for (int j = 0; j < i; j++) {
            if (arr[j] > arr[j + 1]) {
                flag = 1;
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        if (flag == 0) {
            break;
        }
        flag = 0;
    }
    //输出结果
    for (int i = 0; i < arr.size(); i++) {
        printf("%d ", arr[i]);

    }
}
```

