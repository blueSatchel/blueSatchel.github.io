---
title: 图
date: 2024-10-04 10:54:14
tags:
	  - 图
	  - 算法
---

# 图

记录一些图里面不太系统的代码

#### 邻接表创建图

创建一个无向图,熟悉一下大概代码就行,考试也用不到

这个无向图的原始图

![image-20241004115943647](https://blue-satchel.oss-cn-chengdu.aliyuncs.com/img/202410041159712.png)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef struct arcNode{
    int adjVex;
    struct arcNode* nextArc;
}arcNode;
typedef struct vNode{
    int val;//顶点值
    arcNode *firstArc;//第一条边
}vNode;

void addEdge(vector<vNode>& vertices,int start,int end){
    //无向图要一次在里面插两个边表结点,这里采用头插法
    arcNode* arc=(arcNode*)malloc(sizeof(arcNode));
    arc->adjVex=end;
    arc->nextArc=NULL;
    arc->nextArc=vertices[start].firstArc;
    vertices[start].firstArc=arc;

    arcNode *arc2=(arcNode*)malloc(sizeof(arcNode));
    arc2->adjVex=start;
    arc2->nextArc=NULL;
    arc2->nextArc=vertices[end].firstArc;
    vertices[end].firstArc=arc2;
}
void printGraph(vector<vNode> vertices){
    for(int i=0;i<vertices.size();i++){
        arcNode* temp=vertices[i].firstArc;
        while(temp){
            printf("%d -> %d\n",vertices[i].val,temp->adjVex);
            temp=temp->nextArc;
        }
    }
}
int main() {
    vector<vNode> vertices(5);//顶点表
    for(int i=0;i<5;i++){
        vertices[i].val=i;
        vertices[i].firstArc=NULL;
    }

    addEdge(vertices,0,1);
    addEdge(vertices,0,4);
    addEdge(vertices,1,2);
    addEdge(vertices,1,3);
    addEdge(vertices,1,4);
    addEdge(vertices,2,3);
    addEdge(vertices,3,4);
    printGraph(vertices);
    return 0;
}

```

![image-20241004105622581](https://blue-satchel.oss-cn-chengdu.aliyuncs.com/img/202410041056719.png)

### 深搜和广搜

<img src="https://blue-satchel.oss-cn-chengdu.aliyuncs.com/img/202410041200771.png" alt="image-20241004115943647" style="zoom:67%;" />

#### 深度优先遍历

##### 基于邻接表

用上边代码生成的无向图的邻接表进行深搜

```cpp
void DFS(vector<vNode>G,int startVertex,vector<bool>& visited){
    visited[startVertex]=true;
    printf("%d  ",G[startVertex].val);
    arcNode * p=G[startVertex].firstArc;
    while(p){
        if(visited[p->adjVex]==false){
            DFS(G,p->adjVex,visited);
        }
        p=p->nextArc;
    }
}
main函数中创建一个visited数组并从起始点调用DFS
    vector<bool> visited(5,false);
    DFS(vertices,1,visited);
```

##### 基于邻接矩阵



#### 广度优先遍历

##### 基于邻接表

注意:对于广度优先遍历,要在结点入队之前就对其进行访问标记

```cpp
void BFS(vector<vNode>G,int startVertex,vector<bool>& visited){
    queue<vNode> q;
    visited[startVertex]=true;
    //访问
    printf("%d ",startVertex);
    q.push(G[startVertex]);
    while(!q.empty()){
        vNode temp=q.front();
        q.pop();
        arcNode *p=temp.firstArc;
        while(p){
            if(visited[p->adjVex]==false){
                //访问
                printf("%d ",p->adjVex);
                visited[p->adjVex]=true;
                //把刚刚访问过的结点入队
                q.push(G[p->adjVex]);
            }
            p=p->nextArc;
        }

    }
}
main函数中创建一个visited数组并从起始点调用DFS
    vector<bool> visited(5,false);
    BFS(vertices,1,visited);
```

##### 基于邻接矩阵

