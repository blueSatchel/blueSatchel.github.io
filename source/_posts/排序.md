---
title: 排序
date: 2022-01-07 21:39:01
categories: 数据结构
tags: 
      - 数据结构
      - c/c++
typora-root-url: ..
---

## 排序

#### 排序的分类

##### 按照存储介质可以分为:

- 内部排序: 数据量不大,数据在内存,无需内外村交换数据
- 外部排序: 数据量不大,数据在外存 (文件排序)

外部排序时,<!--more-->要将数据分批调入内存来排序,中间结果还要及时放入外存,显然外部排序更复杂

##### 按照比较器个数可以分为:

- 串行排序: 单处理机 (同一时刻比较一对元素)
- 并行排序: 多处理机 (同一时刻比较多对元素)

##### 按主要操作可分为:

- 比较排序:用比较的方法

插入排序,交换排序,选择排序,归并排序

- 基数排序:不比较元素的大小,仅仅根据元素本身的取值确定其有序位置

##### 按辅助空间可分为:

- 原地排序: 辅助空间用量为O(1)的排序方法

(所占的辅助存储空间与参加排序的数据量大小无关)

- 非原地排序: 辅助空间用量超过O(1)的排序方法

##### 按稳定排序可分为:

- 稳定排序:能够使任何数值相等的元素,排序前后相对次序不变
- 非稳定排序:不是稳定排序的方法

**排序的稳定性只对结构类型数据排序有意义**,排序方法是否稳定并不能衡量一个排序算法的优劣

##### 按自然性可分为:

- 自然排序:输入数据越有序,排序的速度越快的排序方法
- 非自然排序:不是自然排序的方法

## 插入排序

### 直接插入排序

边插入边排序,保证子序列都是排好序的,选取元素插入到已经有序的序列中

在插入排序中也可以使用哨兵,0号位置做哨兵

##### 性能分析

基本操作有两个,1.比较关键字大小,2.移动记录

- 最好情况(已经有序)

比较次数n-1,移动次数0

- 最坏情况(逆序有序)

比较次数n(n-1)/2

##### 时间复杂度

原始数据越接近有序,排序速度越快

最坏情况下(逆序有序) O(n2)

最好情况,已经有序,0+1+1+1…… ->O(n)

平均情况下耗时差不多是最坏情况的一半O(n2)

### 折半插入排序

插入位置为high+1

```c++
void BInsertSort(SqList &L){
    for(int i=2;i<=length;i++){//以此插入第2-n个元素
        L.r[0]=L.r[i];//当前插入元素存到哨兵位置
        low =1;high=i-1;//采用二分查找法查找插入位置
        while(low<=high){
            mid =(low+high)/2;
            if(L.r[0].key<L.r[mid].key){
                hith = mid - 1;           
            }else{
                low =mid +1;
            }            
        }
        for(int j=i-1;j>=high+1;--j){
            L.r[j+1]=L.r[j];//移动元素
        }
        L.r[high+1]=L.r[0];//插入到正确位置
    }
}
```

**二分插入排序比较次数与待排序的记录的初始排列状态无关**

在对象的初始排列已经有序或者接近有序的情况下,直接插入排序比较次数比折半插入排序少

减少了比较次数,不能减少移动次数

平均性能优于直接插入排序

##### 时间复杂度

O(n2)

##### 空间复杂度

O(1)

**是一种稳定的排序方法**

### 希尔排序

基本思想:先将整个待排记录序列分割成若干子序列,分别进行直接插入排序,待整个序列中的记录”基本有序”时,再对全体记录进行一次直接插入排序

##### 特点

- 一次移动,移动位置较大,跳跃式地接近排序后的最终位置
- 最后一次只需要少量移动
- 增量序列必须是递减的,最后一个必须是1
- 增量序列应该是**互质**的

以特定间隔的元素分为一组进行插入排序,最后递减成1间隔的插入排序

步骤

- 1.定义增量序列Dk:DM>DM-1>…>D1=1
- 2.对每个Dk进行”Dk间隔”插入排序

希尔排序算法是一种不稳定的排序算法

##### 时间复杂度

O(n1.25)~O(1.6n1.25) —-经验公式

O(Nlog2N) —平均时间复杂度

最差时间复杂度O(n2)

##### 空间复杂度

O(1) –本质还是插入排序

##### 注意:

- 如何选取最佳增量序列,目前尚未解决
- 增量因子中除1外没有公因子(也就是增量因子互质)，且最后一个增量因子必须为1
- 不适合在链式存储结构上实现

## 交换排序

### 冒泡排序

**冒泡排序算法是稳定的**

##### 冒泡排序算法改进

如果某一趟发现没有产生任何交换,则说明该序列已经有序,后面的几趟就不需要比了,所以可以做出冒泡算法的改进

```c++
void bubble_sort(SqList &L){//改进的冒泡算法
    int m,i,j,flag=1;
    RedType x;//temp变量
    for(m=1;m<n-1&&flag==1;m++){
        flag=0;
        for(j=1;j<=m;j++){
            if(L.r[j].key>L.r[j+1].key){//发生逆序
                flag=1;//发生交换,flag置为1,若本趟没发生交换,flag保持为0
                x=L.r[j];
                L.r[j]=L.r[j+1];
                L.r[j+1]=x;//交换
            }//endif
        }//for
    }//for
}
```

**优点**:每趟结束时,不仅能挤出一个最大值到最后面位置,还能同时部分理顺其他元素

##### 时间复杂度

- 最好情况(正序)
  - 比较次数:n-1
  - 移动次数:0

时间复杂度 O(n)

- 最坏情况(逆序)
  - 比较次数:1/2(n2-n)
  - 移动次数:3/2(n2-n)

时间复杂度O(n2)

**平均时间复杂度O(n2)**

**空间复杂度O(1)**

### 快速排序

**快速排序算法是不稳定的**

**快速排序算法不是自然排序方法**

##### 基本思想:

- 任取一个元素为中心(枢轴)
- 所有比它小的元素往前放,比他大的元素往后放,形成左右两个子表
- 对各个子表重新选择中心元素并依次规则调整
- 直到每个子表的元素只剩一个

```c++
int Partition(SqList &L,int low,int high){
    L.r[0]=L.r[low];
    pivotkey=L.r[low].key;
    while(low<high){
        while(low<high&&L.r[high].key>=pivotkey)
            --high;
        L.r[low]=L.r[high];
        while(low<high&&L.r[high].key<=pivotkey)
            ++low;
        L.r[high]=L.r[low];
    }
    L.r[low]=L.r[0];
    return low;//返回枢轴最终的位置
}
void QSort(SqList &L,int low,int high){
    if(low <high){//low==high即各个子表都只有一个元素
        pivotloc=Partition(L,low,high);
        //将L.r[low...high]一分为二,pivotloc为枢轴元素排好序的位置
        QSort(L,low,pivotloc-1);//对低子表递归排序
        QSort(L,low,pivotloc-1);//对高子表递归排序     
    }
}
void main(){
	QSort(L,1,L.length);
}
```

##### 时间复杂度O(nlog2n)

- QSort(); ——O(log2n)
- Partition();——-O(n)

实验结果表明,就平均计算时间而言,快速排序是我们所讨论的所有内排序方法中最好的一个

##### 空间复杂度

快速排序不是原地排序

由于程序中使用了递归,需要递归调用栈的支持,而栈的长度取决于递归调用的深度,(即使不用递归,也需要用用户栈)

- 在平均情况下需要O(log2n)的栈空间
- 最快情况下:栈空间可达O(n)

##### 注意

- 冒泡排序不适合对原本有序或者基本有序的记录序列进行排序,此时会退化成没有改进的**冒泡排序**时间复杂度O(n2)

### 简单选择排序

**简单选择排序算法是不稳定的**

基本思想:在待排序的数据中选出最大(小)的元素放在其最终的位置

基本操作

1. 首先通过n-1次关键字比较,从n个记录中找出关键字最小的记录,将它与第一个记录交换
2. 再通过n-2次比较,从剩余的n-1个记录中找出关键字次小的记录,将它与第二个记录交换
3. 重复上述操作,共进行n-1趟排序后,排序结束

移动次数

- 最好情况 0
- 最好情况 3(n-1)

**比较次数是”定”值**n(n-1)/2

##### 时间复杂度

O(n2)

### 堆排序

**堆排序是不稳定的**

若在输出对堆顶的最小值(最大值)后,使得剩余n-1个元素的序列又建成一个堆,则得到n个元素的次小值(次大值)….如此反复,便能得到一个有序序列,这个过程称之为堆排序

##### 优点

在数据元素各种情况下时间复杂度都是O(nlog2n)

#### 如何调整剩余元素成为一个新的堆

##### 小根堆

1. 输出堆顶元素之后,以堆中最后一个元素替代之,(堆中元素一般用顺序存储结构)
2. 然后将根节点值与左,右子树的根节点值进行比较,并与区中小者进行交换
3. 重复上述操作,直到叶子结点,将得到新的堆,称这个从顶堆至叶子的调整过程为”筛选”

##### 大根堆

同上

#### 堆的建立

单节点的二叉树是堆

在完全二叉树中所有以叶子结点(序号i>n/2)为根的子树是堆

这样,只需依次将以序号为n/2,n/2-1,n/2-2,…,1的结点为根的子树均调整为堆即可

##### 时间复杂度O(nlog2n)

O(n)+O(nlog2n)=O(nlog2n)

初始化堆所需时间不超过—O(n)

排序阶段(不含初始化堆)—O(nlog2n)

##### 空间复杂度O(1)

##### 代码实现

```c++
堆排序
#include<iostream>
#include<algorithm>
using namespace std;
class Heap {//创建堆对象
public:
       void heap(int arr[],int lenth,int index){//创建建立大根堆的函数
              if (lenth <= 1)
                      return;//当剩余长度小于等于1的时候推出
              int left = index * 2 + 1;//左节点等于父节点*2+1
              int right = index * 2 + 2;//右节点等于父节点*2+2
              int max = index;//初始化一个max为传入的根节点
              if (left<lenth && arr[left]>arr[max])
                      max = left;//判断子节点是否大于父节点,并且更改max指向的值
              if (right<lenth && arr[right]>arr[max])
                      max = right;
              if (arr[index] != arr[max]) {//判断根节点是否为最大值,若不是则交换
                      swap(arr[index], arr[max]);
                      heap(arr, lenth, max);//递归调用,将
              }
                             
       }
       void heapSort(int arr[], int size) {
              for (int i = size / 2 - 1; i >= 0; i--) {
                      heap(arr, size, i);//建立一个大根堆
              }
              for (int i = size - 1; i >= 1; i--) {
                      swap(arr[0], arr[i]);
                      heap(arr, i, 0);//重新调整大根堆
              }
       }
};
int main() {
       Heap A;
       int arr[5] = { 5,7,3,4,8 };
       A.heapSort(arr, 5);
       for (int i = 0; i < 5; i++) {
              cout << arr[i] << endl;
       }
       return 0;
}
```

### 归并排序

**归并排序是稳定的**

##### 时间复杂度O(nlog2n)

##### 空间复杂度O(n)

因为需要一个与原始序列同样大小的辅助序列,这正是此算法的缺点(归并排序后的值往辅助序列中填)

##### 代码实现(递归)

```c++
#include<iostream>
#include<vector>
//引入vector是为了定义可变数组
using namespace std;
class Merge {
public:
       void merge(int arr[],int left,int mid,int right) {
              vector<int> help(right -left+1);
                  //定义一个长度为right -left+1的数组,进行内排
                int i = 0;
              int p1 = left, p2 = mid+1;
              while (p1 <= mid && p2 <= right) {
                      help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
              }
              while (p1 <= mid)
                      help[i++] = arr[p1++];
              while (p2 <= right)
                      help[i++] = arr[p2++];
              for (int j = 0; j < help.size(); j++) {
                      arr[left+j] = help[j];
              }
       }
       void mergeSort(int arr[],int left,int right) {
              if (left == right)
                      return;
              int mid = left + ((right-left)>> 1);
              mergeSort(arr, left, mid);
              mergeSort(arr, mid + 1, right);
              merge(arr, left, mid, right);
       }
};
int main() {
       Merge A;
       int arr[10] = { 3,4,6,1,4,3,6,7,9,87 };
       A.mergeSort(arr, 0, 9);
       for (int i = 0; i < 10; i++) {
              cout <<"  "<< arr[i]<<flush;
       }
       return 0;
}
```

### 基数排序

也叫桶排序或箱排序:设置若干个箱子,将关键字为k的记录放入第k个箱子,然后再按照序号将非空的连接

数字是有范围的,只需要设置0-9十个箱子,相继按照个,十,百,….进行排序

##### 基本思想

分配+收集

##### 步骤

- 第一趟收集保证个位有序
- 第二趟收集保证十位有序
- ………..

##### 时间复杂度O(k*(n+m))

- k: 关键字个数
- m: 关键字取值范围为m个值

##### 空间复杂度O(n+m)



## 各种常见内排序算法复杂度以及稳定性表格

![image-20220614200227899](https://blue-satchel.oss-cn-chengdu.aliyuncs.com/image-20220614200227899.png)
